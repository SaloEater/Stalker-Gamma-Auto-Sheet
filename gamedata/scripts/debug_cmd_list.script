local cmd = {}

function command_get_list()
	return cmd
end

function command_get_count()
	local count = 0
	for k,v in pairs(cmd) do
		count = count + 1
	end
	return count
end

function command_exists(name)
	return cmd[name] ~= nil
end

function command_give(name,...)
	return cmd[name](name,...)
end

function split(txt)
	args = {}
	for x in txt:gmatch("%S+") do table.insert(args, x) end
	return args
end

local function trim(s)
	return string.gsub(s, "^%s*(.-)%s*$", "%1")
end

local function first_word(txt)
	local _strt, _end = string.find(txt,".%S+")
	if (_strt and _end) then
		return trim(string.lower(string.sub(txt,_strt, _end))),trim(string.sub(txt,_end+1))
	end
	return "",""
end 

function check_and_set_help(caller,txt,owner,msg)
	local wrd,rest = first_word(txt)
	
	if (wrd == "") then 
		owner:SendOutput("For usage type %s help",caller)
		return
	end 
	
	if (string.find(wrd,"help")) then
		owner:SendOutput("%s %s",caller,msg)
		return
	end
	return wrd,rest
end

-- HELP
function cmd.help(me,txt,owner,p)
	local wrd,rest = first_word(txt)
	local page = tonumber(txt) or 1
	local sz = owner.console_size

	if not (sz) or (sz == 0) then return "help := error" end

	local a = {}
    for n in pairs(cmd) do
		if (n ~= "help") then
			table.insert(a, n)
		end
	end
    table.sort(a)
	
	local page_count = math.ceil(#a/sz)
	if (page > page_count) then
		return "help:= Invaild page"
	end
	
	owner:SendOutput("help := Command List [%s of %s]",page,page_count)
	owner:SendOutputList(a,(page*sz)-sz,sz-1)
end

-- ECHO
function cmd.echo(me,txt,owner,p)
	return txt
end

function cmd.char_desc(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[checkall]")
	if not (wrd) then return end
	if not (wrd == "checkall") then return "char_desc:= try char_desc checkall" end
	
	local f = {	"character_desc_agroprom",
				"character_desc_bar",
				"character_desc_darkvalley",
				"character_desc_deadcity",
				"character_desc_escape",
				"character_desc_general",
				"character_desc_jupiter",
				"character_desc_katacomb",
				"character_desc_marsh",
				"character_desc_military",
				"character_desc_pripyat",
				"character_desc_red_forest",
				"character_desc_simulation",
				"character_desc_underpass",
				"character_desc_yantar",
				"character_desc_zaton"
			}
			
	local tags = {			["name"] = false,
							["icon"] = false,
							["map_icon"] = false,
							--["bio"] = false,
							["class"] = false,
							["community"] = false,
							["terrain_sect"] = false,
							["money"] = false,
							["rank"] = false,
							["reputation"] = false,
							["visual"] = false,
							--["snd_config"] = false,
							["supplies"] = false,
							--["actor_dialog"] = false
	}
	
	local xml,node,id,char_node,p
	for i=1,#f do 
		xml = utils_xml.XmlParser:loadFile(getFS():update_path('$game_config$', '').."gameplay\\"..f[i]..".xml")
		if (xml) then
			for index,node in pairs(xml.ChildNodes) do
				if (type(node) == "table") then

					-- Check if all specific_character nodes for mandatory child nodes
					for k,child in pairs(node.ChildNodes) do
						if (type(child) == "table") then
							if (tags[child.Name] == false) then 
								tags[child.Name] = true
							end
						end
					end	

					-- Validate that all nodes by tag names exist
					for k,v in pairs(tags) do 
						if (v == false) then 
							owner:SendOutput("char_desc:= specific character id=%s missing a mandatory node by name %s",node.Attributes.id,k)
						end
						-- reset for next loop
						tags[k] = false
					end
					
				end
			end
		else
			owner:SendOutput("char_desc:= no xml by name %s",f[i])
		end 
	end
	return "char_desc:= scanning complete"
end 

-- print
function cmd.print(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[_G]")
	if not (wrd) then return end
	
	if (wrd == "_G" or wrd == "_g") then 
		local list = { f={}, t={}, u={}, b={}, n={}, s={}, unknown={} }
		
		local msg = ""
		for k,v in pairs(_G) do 
			if (type(v) == "userdata") then 
				table.insert(list.u,k)
			elseif (type(v) == "function") then 
				table.insert(list.f,k)
			elseif (type(v) == "boolean") then 
				table.insert(list.b,k)
			elseif (type(v) == "number") then 
				table.insert(list.n,k)
			elseif (type(v) == "string") then 
				table.insert(list.s,k)
			elseif (type(v) == "table") then 
				table.insert(list.t,k)
			else 
				table.insert(list.unknown,k)
			end
		end
		
		for k,v in pairs(list) do 
			table.sort(v)
		end
		
		msg = msg .. "\n\nNUMBER" .. "\n"
		for i=1,#list.n do
			msg = msg .. list.n[i] .. " = " .. tostring(_G[list.n[i]]) .. "\n"
		end
		
		msg = msg .. "\n\nBOOLEAN" .. "\n"
		for i=1,#list.b do
			msg = msg .. list.b[i] .. " = " .. tostring(_G[list.b[i]]) .. "\n"
		end		
		
		msg = msg .. "\n\nSTRING" .. "\n"
		for i=1,#list.s do
			msg = msg .. list.s[i] .. " = " .. _G[list.s[i]] .. "\n"
		end
		
		msg = msg .. "\n\nTABLE" .. "\n"
		for i=1,#list.t do
			msg = msg .. list.t[i] .. "\n"
		end
	
		msg = msg .. "\n\nFUNCTION" .. "\n"
		for i=1,#list.f do
			msg = msg .. list.f[i] .. "\n"
		end
		
		msg = msg .. "\n\nUSERDATA" .. "\n"
		for i=1,#list.u do
			msg = msg .. list.u[i] .. "\n"
		end
		
		msg = msg .. "\n\nUNKNOWN" .. "\n"
		for i=1,#list.unknown do
			msg = msg .. list.unknown[i] .. "\n"
		end
		
		local file = io.open("debug_print.txt","w")
		file:write(msg)
		file:close()
		return "print:= output sent to debug_print.txt"
	end 
	
	return "print:= incorrect subcommands. Type 'print help'"
end 

-- reload_system_ini and language
function cmd.reload_system_ini(me,txt,owner,p)
	reload_ini_sys()
	game.reload_language()
	
	return "reload_system_ini:= success"
end

-- Relations
function cmd.relations(me,txt,owner,p)
	owner:SendOutput("Stalker = %s",relation_registry.community_goodwill("stalker", 0))
	owner:SendOutput("Bandit = %s",relation_registry.community_goodwill("bandit", 0))
	owner:SendOutput("Mercenary = %s",relation_registry.community_goodwill("killer", 0))
	owner:SendOutput("CSky = %s",relation_registry.community_goodwill("csky", 0))
	owner:SendOutput("Freedom = %s",relation_registry.community_goodwill("freedom", 0))
	owner:SendOutput("Duty = %s",relation_registry.community_goodwill("dolg", 0))
	owner:SendOutput("Army = %s",relation_registry.community_goodwill("army", 0))
	owner:SendOutput("Monolith = %s",relation_registry.community_goodwill("monolith", 0))
	owner:SendOutput("Ecolog = %s",relation_registry.community_goodwill("ecolog", 0))
	owner:SendOutput("Renegade = %s",relation_registry.community_goodwill("renegade", 0))
	owner:SendOutput("Sin = %s",relation_registry.community_goodwill("greh", 0))
	owner:SendOutput("ISG = %s",relation_registry.community_goodwill("isg", 0))
	return "relations:= command finished"
end 

-- Lua Count All
function cmd.lua_countall(me,txt,owner,p)
	local seen = {}
	local function count_all(f)
		local function count_table(t)
			if seen[t] then return end
			f(t)
			seen[t] = true
			for k,v in pairs(t) do
				if type(v) == "table" then
					count_table(v)
				else
					f(v)
				end
			end
		end
		count_table(_G)
	end

	local count = 0
	local function track(o)
		if (type(o) == "function") then 
			count = count + 1
		end
	end
	
	count_all(track)
	
	output = strformat("%s functions. %s bytes used",count,count*20)
	
	return "lua_countall:= " .. output
end 

-- Community
function cmd.community(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<community>")
	if not (wrd) then return end
	
	local comm_list = utils_obj.get_communities_list()
	for i=1,#comm_list do 
		if (wrd == comm_list[i]) then 
			set_actor_true_community(wrd)
			return "community:= actor community successfully changed to "..wrd
		end
	end
	return "community:= invalid community"
end
-- SPAWN
--[[
example usage:

spawn s:stalker id:%s amt:5 $AC_ID     -- Spawns 5 stalkers at actor's position

spawn s:wpn_pm id:5424 						   -- Spawns Pistol on ID's position

spawn s:wpn_pm id:$AC_ID$

spawn s:wpn_pm pos:244,355,123 lvid:11344 gvid:12  -- Spawns pistol at exact location

--]]
function cmd.spawn(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"s:<section> id:<number> amt:<number> [ pos:<x,y,z> lvid:<x,y,z> gvid:<x,y,z> ]")
	if not (wrd) then return end

	if (wrd == "reset") then
		owner.spawn_pos = nil
		owner.spawn_lvid = nil
		owner.spawn_gvid = nil
		return "spawn:= position reset to always actor"
	end

	if (wrd == "items") then
		if not (ini_sys:section_exist("inv_backpack")) then
			return "spawn:= requires inv_backpack from items_minimod"
		end
		local stash = alife_create("inv_backpack",db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id())
		local itm
		if not (se_item.registered_items) then 
			return "spawn:= registered items table needs uncommented in se_item.script"
		end
		for k,v in pairs(se_item.registered_items) do
			alife_create_item(k, stash)
		end
		return "spawn:= all registered items in game spawned in a stash near you"
	end

	local sec
	if (string.find(txt,"s:")) then
		for s in string.gmatch(txt,"s:(.%S+)") do
			sec = s
		end
	end

	if not (sec) or not (ini_sys:section_exist(sec)) then
		return "spawn:= Section %s does not exist.",sec
	end

	local pos,lvid,gvid,id

	if (string.find(txt,"id:")) then
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end

		local obj = level.object_by_id(id)
		if (obj) then
			pos = obj:position()
			lvid = obj:level_vertex_id()
			gvid = obj:game_vertex_id()
		end
	else
		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
				local p = str_explode(s,",")
				pos = vector():set(tonumber(p[1]),tonumber(p[2]),tonumber(p[3]))
			end

			if (string.find(txt,"lvid:")) then
				for s in string.gmatch(txt,"lvid:(%w+)") do
					lvid = tonumber(s)
				end
			else
				return "spawn:= Must specify level_vertex_id along with position."
			end

			if (string.find(txt,"gvid:")) then
				for s in string.gmatch(txt,"gvid:(%w+)") do
					gvid = tonumber(s)
				end
			else
				return "spawn:= Must specify game_vertex_id along with position."
			end
		else
			return "spawn:= Must specify id or position. Type spawn help"
		end
	end

	local amt = 1
	if (string.find(txt,"amt:")) then
		for s in string.gmatch(txt,"amt:(%d+)") do
			amt = tonumber(s)
		end
	end

	if (pos) and (lvid) and (gvid) then
		for i=1,amt do
			local obj = alife_create_item(sec, {pos,lvid,gvid,id})
		end

		if (amt > 1) then
			return "Spawn:= Objects created"
		end

		if not (obj) then
			return "spawn:= Object nil"
		end
		return "spawn:= Object %s created as ID %s.",obj:name(),obj.id
	end

	local p = string.format("%0.2f,%0.2f,%0.2f",pos.x,pos.y,pos.z)
	return "spawn:= Error pos=%s lvid=%s gvid=%s",p,lvid,gvid
end

-- collectgarbage
function cmd.collectgarbage(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[full|count|step]")
	if not (wrd) then return end

	if (wrd == "full") then
		local before = collectgarbage("count")
		collectgarbage()
		local after = collectgarbage("count")
		return "collectgarbage:= |before|=>"..before.." |after|=> "..after
	elseif (wrd == "count") then
		local count = collectgarbage("count")
		return "collectgarbage:= "..count
	elseif (wrd == "step") then
		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
			local amt = wrd and wrd ~= "" and tonumber(wrd) or 0
			if (amt) then
				xrs_debug_tools.STEP = amt
			end
		end
	else
		return "collectgarbage:= wrong argument passed."
	end
end

function cmd.attach(me,txt,owner,p)
	local wpn = db.actor:active_item()
	if (wpn) then
		local firearm = IsWeapon(wpn)
		if (firearm) then
			if (wpn.weapon_addon_attach) then
				local addons = {
					"wpn_addon_scope",
					"wpn_addon_scope_x2.7",
					"wpn_addon_scope_detector",
					"wpn_addon_scope_night",
					"wpn_addon_scope_susat",
					"wpn_addon_scope_susat_x1.6",
					"wpn_addon_scope_susat_custom",
					"wpn_addon_scope_susat_dusk",
					"wpn_addon_scope_susat_night",
					"wpn_addon_silencer",
					"wpn_addon_grenade_launcher",
					"wpn_addon_grenade_launcher_m203"
					}
				local addon
				local attached = false
				for k,v in pairs(addons) do
					addon = db.actor:object(k)
					if (addon) then 
						wpn:weapon_addon_attach(addon)
						attached = true
					end
				end 
				
				if (attached) then 
					return "attach:= addon attached"
				end 
				return "attach:= no addons attached"
			else 
				return "attach:= weapon does not have weapon_addon_attach method"
			end
		end 
	end
	return "attach:= addon was not attached for active weapon"
end 

function cmd.detach(me,txt,owner,p)
	local wpn = db.actor:active_item()
	if (wpn) then
		local firearm = IsWeapon(wpn)
		if (firearm and wpn.weapon_addon_detach) then
			local addons = {
				"wpn_addon_scope",
				"wpn_addon_scope_x2.7",
				"wpn_addon_scope_detector",
				"wpn_addon_scope_night",
				"wpn_addon_scope_susat",
				"wpn_addon_scope_susat_x1.6",
				"wpn_addon_scope_susat_custom",
				"wpn_addon_scope_susat_dusk",
				"wpn_addon_scope_susat_night",
				"wpn_addon_silencer",
				"wpn_addon_grenade_launcher",
				"wpn_addon_grenade_launcher_m203"
				}
			local addon
			for k,v in pairs(addons) do
				wpn:weapon_addon_detach(k)
			end 

			return "detach:= check item"
		end 
	end
	return "detach:= addon was not detached from active weapon"
end 

local function parse_waypoint(pathname, wpflags, wpname, owner, tRet)

	local rslt = {}

	rslt.flags = wpflags

	local at
	if string.find(wpname, "|", at, true) == nil then
		return rslt
	end

	--[[
	file = io.open("axr_debug_log.txt","a+")
	if (file) then
		file:write(strformat("[%s] %s", pathname, wpname).."\n")
		file:close()
	end
	--]]

	local par_num
	local fld
	local val

	par_num = 1
	for param in string.gmatch(wpname, "([%w%+~_\\%=%{%}%s%!%-%,%*]+)|*") do
		if par_num == 1 then
			-- continue
		else
			if param == "" then
				owner:SendOutput("path '%s': waypoint '%s': syntax error in waypoint name", pathname, wpname)
				printf("path '%s': waypoint '%s': syntax error in waypoint name", pathname, wpname)
			else
				local t_pos = string.find(param, "=", 1, true)
				if (t_pos) then
					fld = string.sub(param, 1,t_pos - 1)
					if not (fld and fld ~= "") then
						tRet[#tRet+1] = strformat("path '%s': waypoint '%s': syntax error while parsing the param '%s': no field specified",pathname, wpname, param)
						printf("path '%s': waypoint '%s': syntax error while parsing the param '%s': no field specified",pathname, wpname, param)
					else
						val = string.sub(param, t_pos + 1)
						if not (val and val ~= "") then
							val = "true"
						end

						if fld == "a" then
							rslt[fld] = xr_logic.parse_condlist(db.actor, "waypoint_data", "anim_state", val)

							if not (state_lib.states[val]) then
								tRet[#tRet+1] = strformat("path '%s': waypoint '%s': not a valid state_lib anim  %s", pathname, wpname,val)
								printf("path '%s': waypoint '%s': not a valid state_lib anim %s", pathname, wpname,val)
							end
						else
							rslt[fld] = val
						end
					end
				else
					tRet[#tRet+1] = strformat("path '%s': waypoint '%s': syntax error in waypoint name", pathname, wpname)
					printf("path '%s': waypoint '%s': syntax error in waypoint name", pathname, wpname)
				end
			end
		end
		par_num = par_num + 1
	end
	return rslt
end

function cmd.waypoint(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[checkall | checklevel | checkindex]")
	if not (wrd) then return end

	if not (wrd == "checkall" or wrd == "checklevel" or wrd == "checkindex") then
		return "waypoint:= invalid argument. Type waypoint help for a list of subcommands"
	end

	local npc = xrs_debug_tools.get_debug_npc()
	if (npc == nil and wrd == "checklevel" and npc:id() ~= 0) then
		return "waypoint:= need NPC to validate waypoints, no nearest stalker found."
	end

	local path_jobs = {"surge","collector","walker","patrol","guard","sniper","camper","sleep"}

	local smart,gname,name,ptr,cnt,i,vec
	local b = {}
	local last_index

	local sim = alife()
	local actor_level = wrd == "checklevel" and sim:level_name(game_graph():vertex(sim:actor().m_game_vertex_id):level_id()) or "nil"

	local checked = false
	local gg = game_graph()
	
	local t = {}
	for id=1,65534 do
		smart = sim:object(id)
		if (smart and smart:clsid() == clsid.smart_terrain) then
			gname = smart:name()
			if (wrd == "checkindex") then
				checked = true
				for index,job in ipairs(path_jobs) do
					b=empty_table(b)
					last_index = 0
					for add=1,20 do
						name = job == "sleep" and gname.."_"..job.."_"..add or gname.."_"..job.."_"..add.."_walk"
						ptr = patrol(name)
						if (ptr) then
							b[add] = name
							last_index = add
						end						
					end
					for add=1,last_index do 
						if b[add] == nil then 
							t[#t+1] = strformat("path %s does not exist!",job == "sleep" and gname.."_"..job.."_"..add or gname.."_"..job.."_"..add.."_walk")
						end
					end
				end			
			elseif (wrd == "checkall" or self.is_on_actor_level) then	
				for index,job in ipairs(path_jobs) do
					i = 1
					while level.patrol_path_exists(job == "sleep" and gname.."_"..job.."_"..i or gname.."_"..job.."_"..i.."_walk") do
						name = job == "sleep" and gname.."_"..job.."_"..i or gname.."_"..job.."_"..i.."_walk"
						ptr = patrol(name)
						if (ptr) then
							checked = true
							cnt = ptr:count()
							for n=0,cnt-1 do
							
								if not (gg:valid_vertex_id(ptr:game_vertex_id(n))) then
									t[#t+1] = strformat("path %s p%s:%s does not have valid game_vertex_id",name,n,ptr:name(n))
									printf("path %s p%s:%s does not have valid game_vertex_id",name,n,ptr:name(n))
								end
								
								if (actor_level ~= "nil") then 
									if not (utils_obj.accessible(npc,ptr:level_vertex_id(n))) then
										t[#t+1] = strformat("path %s p%s:%s does not have valid level_vertex_id",name,n,ptr:name(n))
										printf("path %s p%s:%s does not have valid level_vertex_id",name,n,ptr:name(n))
									end
								else 
									if (ptr:level_vertex_id(n) >= 4294967295) then 
										t[#t+1] = strformat("path %s p%s:%s does not have valid level_vertex_id",name,n,ptr:name(n))
										printf("path %s p%s:%s does not have valid level_vertex_id",name,n,ptr:name(n))
									end
								end
								parse_waypoint(name,ptr:flags(n),ptr:name(n),owner,t)
							end
						end
						-- Validate look waypoint also
						name = gname.."_"..job.."_"..i.."_look"
						if (level.patrol_path_exists(name)) then 
							ptr = patrol(name)
							if (ptr) then 
								checked = true
								cnt = ptr:count()
								for n=0,cnt-1 do
									parse_waypoint(name,ptr:flags(n),ptr:name(n),owner,t)
								end
							end
						end
						i = i + 1
					end
				end
			end
		end
	end

	if (checked) then
		if (#t > 0) then
			wrd = ""
			local _strt, _end = string.find(txt,"%d+")
			if (_strt and _end) then
				wrd = string.sub(txt,_strt, _end)
				wrd = string.lower(wrd)
			end

			local page = wrd ~= "" and tonumber(wrd) or 1

			local sz = owner.console_size

			if not (sz) or (sz == 0) then return "waypoint:= error" end

			local page_count = math.ceil(#t/sz)

			if (page > page_count) then
				return "waypoint:= Invalid page"
			end

			table.sort(t)

			owner:SendOutput("waypoint:= Bad Waypoints [%s of %s]",page,page_count)
			owner:SendOutputList(t,(page*sz)-sz,sz-1)
			return
		end
		return "waypoint: successfully checked all gulag job paths."
	end 
	return "waypoint: failed, no checking done."
end



-- SURGE
function cmd.surge(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[start|stop]")
	if not (wrd) then return end

	local sm = surge_manager.SurgeManager
	if not (sm) then return "No surge manager!" end

	if (wrd == "start") then
		sm:start(true)
		return "surge:= started"
	elseif (wrd == "stop") then
		sm:end_surge(true)
		return "surge:= ended"
	else
		return "surge:= wrong argument passed."
	end
end

-- PsiStorm
function cmd.psi_storm(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[start|stop]")
	if not (wrd) then return end

	local sm = psi_storm_manager and psi_storm_manager.PsiStormManager
	if not (sm) then return "No psi_storm manager!" end

	if (wrd == "start") then
		sm:start(true)
		return "psi_storm:= started"
	elseif (wrd == "stop") then
		sm:finish(true)
		return "psi_storm:= ended"
	else
		return "psi_storm:= wrong argument passed."
	end
end


-- Fallout
function cmd.fallout(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[start|stop]")
	if not (wrd) then return end

	local sm = fallout_manager and fallout_manager.get_fallout_manager()
	if not (sm) then return "No fallout manager!" end

	if (wrd == "start") then
		sm:start(true)
		return "fallout:= started"
	elseif (wrd == "stop") then
		sm:end_surge(true)
		return "fallout:= ended"
	else
		return "fallout:= wrong argument passed."
	end
end


-- Find
function cmd.find(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<name>")
	if not (wrd) then return end

	if (p[1]) then
		owner:FindNearest(p[1])
	else
		owner:FindNearest(wrd)
	end
end

-- Execute
function cmd.execute(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<string>")
	if not (wrd) then return end

	local f,err = assert(loadstring(wrd))
	if (f) then
		f()
	else
		return err
	end
end

-- Alife

function cmd.alife(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{switch}")
	if not (wrd) then return end

	if (string.find(wrd,"switch")) then
		--[[
		if (string.find(txt,"set:")) then
			local d
			for s in string.gmatch(txt,"set:(%d+)") do
				d = tonumber(s)
			end
			if not (d) then
				return "alife := Invalid value for switch distance set:%s",d
			end
			local old = alife():switch_distance()
			alife():switch_distance(d)
			return "alife := switch distance changed from %s to %s",old,d
		elseif (string.find(txt,"get")) then
			local sd = alife():switch_distance()
			return "alife := switch distance is %s",sd
		else
			return "alife switch [get|set:<value>]"
		end
		--]]
		local sd = alife():switch_distance()
		return "alife:= switch distance is %s",sd
	end
end

-- Clear
function cmd.clear(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"(Clears console)")
	if (string.find(txt,"help")) then
		return
	end

	for i=1,owner.console_size do
		owner.txt_console[i]:SetText("")
	end
end

-- Squad
function cmd.squad(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{assign}")
	if not (wrd) then return end

	if (string.find(wrd,"teleport")) then 
		local id,squad,a_id,target
		if (string.find(txt,"id:")) then
			for s in string.gmatch(txt,"id:(%d+)") do
				id = tonumber(s)
			end

			squad = alife_object(id)
			if not (squad) then
				return "squad:= improper id used. id:%s",id
			end
		end
		
		if (string.find(txt,"target:")) then
			for s in string.gmatch(txt,"target:(%d+)") do
				a_id = tonumber(s)
			end

			target = alife_object(a_id)
			if not (target) then
				return "squad:= target by id %s does not exist.",a_id
			end
		end

		if (squad and target) then
			TeleportSquad(squad,target.position,target.m_level_vertex_id,target.m_game_vertex_id)
			return "squad := %s teleported to %s.",squad:name(),target:name()
		end
	elseif (string.find(wrd,"assign")) then
		local id,squad,a_id,target
		if (string.find(txt,"id:")) then
			for s in string.gmatch(txt,"id:(%d+)") do
				id = tonumber(s)
			end

			squad = alife_object(id)
			if not (squad) then
				return "squad:= improper id used. id:%s",id
			end
		end

		if (string.find(txt,"target:")) then
			for s in string.gmatch(txt,"target:(%d+)") do
				a_id = tonumber(s)
			end

			target = alife_object(a_id)
			if not (target) then
				return "squad:= assign target does not exist. assign:%s",a_id
			end
		end

		if (squad and target) then
			utils_obj.assign_squad_to_smart(squad.id,target.id)
			return "squad := %s assigned to %s.",squad:name(),target:name()
		end
	end

	return "squad:= squad assign id:<id> target:<id>"
end

-- Console
function cmd.console(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{relay}")
	if not (wrd) then return end

	if (string.find(wrd,"relay")) then
		if (owner.console_relay) then
			owner.console_relay = false
			return "Toggled off relay to game console"
		else
			owner.console_relay = true
		end
		return "Toggled on relay to game console"
	end
end

-- Teleport
function cmd.teleport(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"who:<id> [ to:<id> | pos:<x,y,z> | $code$ | cam ]")
	if not (wrd) then return end

	local who,to_pos,to_obj

	if (string.find(txt,"who:")) then
		local who_id
		for s in string.gmatch(txt,"who:(%w+)") do
			who_id = tonumber(s)
		end

		who = who_id and alife_object(who_id)
		if not (who) then
			return "teleport := Wrong argument given or object doesn't exist. who:<%s>",who_id
		end
	end

	if (string.find(txt,"to:")) then
		local id
		for s in string.gmatch(txt,"to:(%w+)") do
			id = tonumber(s)
		end

		to_obj = id and alife_object(id)
		if not (to_obj) then
			return "teleport := Wrong arugment given or object doesn't exist. id:%s",id
		end

		to_pos = to_obj.position
	else
		local pos = p[1]

		if (string.find(txt,"cam")) then
			pos = xrs_debug_tools.LastCameraPos
		end

		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
				local t = str_explode(s,",")
				pos = vector():set(tonumber(t[1]),tonumber(t[2]),tonumber(t[3]))
			end
		end

		if not (pos) then
			return "teleport := wrong format for position. pos:%s must be pos:x,y,z"
		end

		to_pos = pos
	end
	
	
	if (who and to_pos) then
		local success = false
		if (who.id == AC_ID) then 
			db.actor:set_actor_position(to_pos)
			success = true
		elseif (to_obj) then
			local squad
			if (IsStalker(who) or IsMonster(who)) then 
				local object = level.object_by_id(who.id)
				if (object) then
					object:set_npc_position(to_pos)
					success = true
				else 
					squad = get_object_squad(who)
				end
			elseif (who:clsid() == clsid.online_offline_group_s) then 
				squad = who
			end 
			
			if (squad and alife().teleport_object) then 
				TeleportSquad(squad,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id())
				success = true
			end
		end
		
		if (success) then 
			local pos = string.format("%0.3f, %0.3f, %0.3f",to_pos.x,to_pos.y,to_pos.z)
			return "teleport:= %s teleported to pos:%s",who:name(),pos
		end
	end
	
	return "teleport:= failed to teleport %s",who and who:name()
end

-- Wound
function cmd.wound(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"id:<number>")
	if not (wrd) then return end

	local id
	local vo
	if (string.find(txt,"id:")) then
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end

		vo = level.object_by_id(id)
		if not (vo) then
			return "wound:= Wrong arugument given or object doesn't exist. id:<%s>",id
		end
	end

	if (vo) then
		vo:set_health_ex(0.05)
		--[[
		local h = hit()
		h.power = vo.health+0.05
		h.direction = vector()
		h.bone = "bip01_spine"
		h.draftsman = vo
		h.impulse = 6000
		h.type = hit.wound
		vo:hit(h)
		--]]
		return "wound:= %s has been wounded.",vo:name()
	end
end

local var_list = { ["actor"] = db.actor}
function get_var_list()
	return var_list
end

-- Var
function cmd.var(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<name> $code$")
	if not (wrd) then return end

	if (wrd == "clear") then
		for k,v in pairs(var_list) do
			var_list[k] = nil
		end
		return "var:= All vars cleared"
	end

	if (wrd == "list") then
		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1
		local sz = owner.console_size-1

		if not (sz) or (sz == 0) then return "var:= error" end

		local list_sz = 0
		for k,v in pairs(var_list) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "var:= Invaild page"
		end

		owner:SendOutput("var:= Variable List [%s of %s]",page,page_count)

		local a = {}
		for n in pairs(var_list) do table.insert(a, n) end
		table.sort(a)

		local ind, out, k
		for i=1,sz do
			ind = (page*sz - sz) + i
			k = ind > 0 and a[ind]
			out = " "

			if (k) then
				local v = var_list[k]
				if ( type(v) == "userdata" ) then
					out = string.format("%s = %s",k,"userdata")
					if (v.name and type(v.name) == "function" ) then
						out = string.format("%s = userdata [%s]",k,v:name())
					elseif (v.position) then
						local pos
						if (type(v.position) == "function") then
							pos = v:position()
							out = string.format("%s = userdata [%s,%s,%s]",k,pos.x,pos.y,pos.z)
						else
							pos = v.position
							out = string.format("%s = userdata [%s,%s,%s]",k,pos.x,pos.y,pos.z)
						end
					elseif (v.x and v.y and v.z) then
						out = string.format("%s = userdata [%s,%s,%s]",k,v.x,v.y,v.z)
					end
				elseif ( type(v) == "number" or type(v) == "string" or type(v) == "table" or type(v) == "function") then
					out = string.format("%s = %s",k,v)
				end
			end
			owner:SendOutput(out)
		end
		return
	end

	if (wrd) then
		var_list[wrd] = p[1]
		return "var:= variable %s set.",wrd
	end
end

-- Vector
function cmd.vector(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{add|sub}")
	if not (wrd) then return end

	if (wrd == "add") then
		local inc = {}

		inc.v = match_or_var(txt,"v:",".%S+",p[1])

		if not (inc.v) then
			return "vector:= Wrong arugument given to inc -> v:"
		end

		inc.x = tonumber( match_or_var(txt,"x:",".%S+",p[2]) ) or 0
		inc.y = tonumber( match_or_var(txt,"y:",".%S+",p[3]) ) or 0
		inc.z = tonumber( match_or_var(txt,"z:",".%S+",p[4]) ) or 0

		inc.v = inc.v:add( vector():set(inc.x,inc.y,inc.z) )
		return "vector:= vector updated to vector"
	end

	if (wrd == "sub") then
		local v = {}

		v[1] = match_or_var(txt,"1:",".%S+",p[1])
		v[2] = match_or_var(txt,"2:",".%S+",p[2])

		if (v[1] and v[2]) then
			local p1,p2
			if ( type(v[1]) == "string" ) then
				p1 = level.object_by_id( tonumber(p1) ):position()
			else
				p1 = v[1]
			end

			if ( type(v[2]) == "string" ) then
				p2 = level.object_by_id( tonumber(p2) ):position()
			else
				p2 = v[2]
			end

			local pr = p1 and p2 and p1:sub(p2)
			if (pr) then
				return "vector:= %s,%s,%s",pr.x,pr.y,pr.z
			end
		end
		return "vector:= Wrong arugument given or object(s) do not exist."
	end
end

-- Offset
function cmd.offset(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{get}")
	if not (wrd) then return end

	if (wrd == "get") then

		if (string.find(txt,"help")) then
			return "offset get [ 1:<id> 2:<id> | 1:<$var$> 2:<$var$> ]"
		end

		local v = {}
		v[1] = match_or_var(txt,"1:",".%S+",p[1])
		v[2] = match_or_var(txt,"2:",".%S+",p[2])

		if (v[1] and v[2]) then
			local p1,p2
			if ( type(v[1]) == "string" ) then
				p1 = level.object_by_id( tonumber(p1) )
			else
				p1 = v[1]
			end

			if ( type(v[2]) == "string" ) then
				p2 = level.object_by_id( tonumber(p2) )
			else
				p2 = v[2]
			end

			local pr = get_position_offset(v[1],v[2])
			if (pr) then
				return "offset:= position(%s,%s,%s)",pr.x,pr.y,pr.z
			end
		else
			return "offset:= type offset get help"
		end
	end

end

function cmd.object(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"{count}")
	if not (wrd) then return end
	
	if (wrd == "count") then
		local count = 0
		local a = alife()
		for i=1, 65534 do 
			local se_obj = a:object(i)
			if (se_obj) then 
				count = count + 1
			end
		end
		return "object:= there are %s ids in use.",count
	end
	return "object:= try object count <number>"
end 

function get_position_offset(npc,o)
	local sec = o and type(o.section) == "function" and o:section()
	if not (sec) then
		return
	end

	local attach_bone_name = ini_sys:r_string_ex(sec,"attach_bone_name")
	if not (attach_bone_name) then
		return
	end
	local pos1 = utils_obj.safe_bone_pos(npc,attach_bone_name)--npc:bone_position(attach_bone_name)
	local pos2 = o:center()
	return pos1:sub(pos2)
end

function match_or_var(txt,token,pat,var)
	if (var and var_list[var]) then
		return var_list[var]
	end

	if (string.find(txt,token)) then
		local v
		for s in string.gmatch(txt,token.."("..pat..")") do
			v = s
		end
		return v
	end
end

-- Hud
function cmd.hud(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		save_var(db.actor,"disable_debug_draw",false)
		return "hud:= debug hud enabled"
	end

	if (wrd == "off") then
		save_var(db.actor,"disable_debug_draw",true)
		return "hud:= debug hud disabled"
	end

	return "hud:= type hud help for list of sub commands"
end

-- God
function cmd.god(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		xrs_debug_tools.debug_god = true
		--exec_console_cmd("g_god on")
		return "god:= invincibility enabled"
	end

	if (wrd == "off") then
		xrs_debug_tools.debug_god = nil
		--exec_console_cmd("g_god off")
		return "god:= invincibility disabled"
	end

	return "god:= type god help for list of sub commands"
end

-- Invisible
function cmd.invisible(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		xrs_debug_tools.debug_invis = true
		return "invisible:= invisibility enabled"
	end

	if (wrd == "off") then
		xrs_debug_tools.debug_invis = nil
		return "invisible:= invisibility disabled"
	end

	return "invisible:= type invisible help for list of sub commands"
end

function cmd.crow(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		local se_crow = utils_obj.nearest_object("m_crow")
		if (se_crow) then
			xrs_debug_tools.crow_fun = se_crow.id
			return "crow:= enabled"
		end
		return "crow:= no crows found"
	end

	if (wrd == "off") then
		xrs_debug_tools.crow_fun = nil
		return "crow:= disabled"
	end

	return "crow:= type crow help for list of sub commands"
end

local heli_id
function cmd.heli(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[spawn|move]")
	if not (wrd) then return end

	if (wrd == "spawn") then
		local se_heli = utils_stpk.spawn_heli()
		if (se_heli) then
			heli_id = se_heli.id
			return "heli:= Spawned at actor position"
		end
		return "heli:= Spawning failed"
	end

	if (wrd == "move") then
		local str
		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:(.%S+)") do
				str = s
			end
		end

		if (str and str ~= "") then
			str = str_explode(str,",")
			str.x = tonumber(str[1])
			str.y = tonumber(str[2])
			str.z = tonumber(str[3])
		end

		local obj = level.object_by_id(heli_id)
		local heli = obj and obj:get_helicopter()
		if (heli) then
			local pos = str or db.actor:position()
			heli:SetDestPosition(vector():set(pos.x,pos.y,pos.z))
			return "heli:= destination set to actor position"
		end
		return "heli:= move failed"
	end

	if (wrd == "attack") then




	end
	return "heli:= type heli help for list of sub commands"
end

-- weather
local weather_list
function cmd.weather(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[list <page> | <weather_name> ]")
	if not (wrd) then return end

	if (wrd == "list") then
		if not (weather_list) then
			weather_list = {}
			local f = getFS()
			local flist = f:file_list_open("$game_weathers$",1)
			local f_cnt = flist:Size()

			for	it=0, f_cnt-1 do
				local file = flist:GetAt(it)
				table.insert(weather_list,file)
			end
			
			flist:Free()
		end

		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1

		local sz = owner.console_size

		if not (sz) or (sz == 0) then return "weather:= error" end

		local list_sz = 0
		for k,v in pairs(weather_list) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "weather:= Invaild page"
		end

		table.sort(weather_list)

		owner:SendOutput("weather:= Weathers List [%s of %s]",page,page_count)
		owner:SendOutputList(weather_list,(page*sz)-sz,sz-1)

		return
	elseif (wrd == "set") then
		level.set_weather(rest,true)
		return "weather:= weather set to " .. rest
		
	elseif (wrd == "reload") then
		weather.reload()
		return "weather:= reloaded weather configs"
	end
	return "weather: type weather help for a list of commands. Exclude .ltx when setting weather"
end

-- time
function cmd.time(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[day,hour,minute]")
	if not (wrd) then return end

	local t = str_explode(txt,",")
	if (t) then
		--set_current_time(tonumber(t[1]),tonumber(t[2]),tonumber(t[3]))
		level.change_game_time( tonumber(t[1]),tonumber(t[2]),tonumber(t[3]) )
		level_weathers.get_weather_manager():forced_weather_change()
	end
end

-- money
function cmd.money(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<amount>")
	if not (wrd) then return end
	local amt = tonumber(wrd) or 1000
	db.actor:give_money(amt)
	return "money:= gave actor "..amt.." RU. You dirty cheater, I'm going to find you and cut your legs off!"
end

-- luabind (not working)
function cmd.luabind(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[list | info]")
	if not (wrd) then return end
	
	if (wrd == "list") then
		if not (_G.class_names) then 
			return "luabind:= error no class_names()"
		end 
		
		local class_names = _G.class_names()
		table.sort(class_names)
		
		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1

		local sz = owner.console_size

		if not (sz) or (sz == 0) then return "luabind:= error" end

		local list_sz = 0
		for k,v in pairs(class_names) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "luabind:= Invaild page"
		end

		owner:SendOutput("luabind:= class_names() [%s of %s]",page,page_count)
		owner:SendOutputList(class_names,(page*sz)-sz,sz-1)
		return
	elseif (wrd == "info") then 
		if not (_G.class_info) then 
			return "luabind:= error no class_info()"
		end 
		
		if (string.find(txt,"help")) then
			return "luabind select userdata:<$var$>"
		end

		local v = {}
		v[1] = match_or_var(txt,"userdata:",".%S+",p[1])
		if (v[1]) then
			local c = class_info(v[1])
			if not (c) then 
				return "luabind:= error; no class info for userdata (not luabind class?)"
			end
			wrd = ""
			local _strt, _end = string.find(txt,"%d+")
			if (_strt and _end) then
				wrd = string.sub(txt,_strt, _end)
				wrd = string.lower(wrd)
			end

			local page = wrd ~= "" and tonumber(wrd) or 1

			local sz = owner.console_size

			if not (sz) or (sz == 0) then return "luabind:= error" end

			local list_sz = 0
			for k,v in pairs(class_names) do
				list_sz = list_sz + 1
			end

			local page_count = math.ceil(list_sz/sz)

			if (page > page_count) then
				return "luabind:= invaild page"
			end
			owner:SendOutput("luabind:= class=%s",c.name)
			owner:SendOutputList(c.methods,(page*sz)-sz,sz-1)
			return
		else
			return "luabind:= no class/userdata specified. (ex. luabind select userdata:$npc$)"
		end 
	end
	return "luabind:= type luabind help for a list of commands"
end 

-- level
function cmd.level(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"<name> | [list]")
	if not (wrd) then return end

	if (wrd == "list") then

		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end
		local page = wrd ~= "" and tonumber(wrd) or 1

		local levels = utils_data.collect_section(game_ini(),"level_maps_single")

		local sz = owner.console_size
		local list_sz = 0
		for k,v in pairs(levels) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "level:= Invaild page"
		end

		owner:SendOutput("level:= list of available levels by name [%s of %s]",page,page_count)
		owner:SendOutputList(levels,(page*sz)-sz,sz-1)

		return
	end
	
	local level_name = level.name()
	if (JumpToLevel(wrd)) then 
		return "level:= level changer successfully created at your position from"..level_name.." to "..wrd.." (Spawning at first found gvid)"
	end

	--[[ depreciated
	local levels = { 	["zaton_jupiter"] = {467.306884765625,55.5276184082031,12.9044094085693},
						["zaton_pripyat"] = {467.206878662109,55.5276184082031,3.20440793037415},
						["jupiter_zaton"] = {-7.12386798858643,14.484338760376,154.085464477539},
						["jupiter_jupiter_underground"] = {460.005798339844,46.0688896179199,-295.460784912109},
						["jupiter_pripyat"] = {-16.3238716125488,14.484338760376,142.785461425781},
						["pripyat_zaton"] = {150.91047668457,22.3456954956055,-287.9228515625},
						["pripyat_jupiter"] = {139.08171081543,22.3457069396973,-287.870025634766},
						["pripyat_labx8"] = {-78.0360107421875,-7.04113388061523,100.684921264648},
						["labx8_pripyat"] = {-78.062873840332,23.8045539855957,100.718994140625}
	}
	local level_name = level.name()
	if (levels[level_name.."_"..wrd]) then
		db.actor:set_actor_position(vector():set(levels[level_name.."_"..wrd][1],levels[level_name.."_"..wrd][2],levels[level_name.."_"..wrd][3]))
		return "level:= teleporting player from "..level_name.." to "..wrd
	end

	local sim = alife()
	local gg = game_graph()
	local level,data
	local default_vertex
	local function create_lc(gvid,vertex)
		local se_obj = sim:create("level_changer",db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id())
		if (se_obj) then
			bind_stalker_ext.REMOVE_ME_LC = se_obj.id
			local lvid = vertex:level_vertex_id()
			local pos = vertex:level_point()

			data = utils_stpk.get_level_changer_data(se_obj)
			if (data) then
				data.dest_game_vertex_id = gvid
				data.dest_level_vertex_id = lvid
				data.dest_position = pos
				data.dest_direction = VEC_ZERO
				data.dest_level_name = level
				data.silent_mode = 1
				
				data.shapes[1] = {}
				data.shapes[1].shtype = 0
				data.shapes[1].offset = VEC_ZERO
				data.shapes[1].radius = 5
				
				data.hint = "level_changer_invitation"

				utils_stpk.set_level_changer_data(data,se_obj)
			end
		end
	end 
	
	for gvid=0, 4836 do
		if gg:valid_vertex_id(gvid) then
			vertex = gg:vertex(gvid)
			level = sim:level_name(vertex:level_id())
			if (level == wrd) then
				if (not vertex.name or string.find(vertex:name(),"actor_spawn")) then
					create_lc(gvid,vertex)
					return "level:= level changer successfully created at your position from"..level_name.." to "..wrd.." (Actor spawn point found!)"
				elseif not (default_vertex) then
					default_vertex = vertex
				end
			end
		else
			break
		end
		gvid = gvid + 1
	end
	
	if (default_vertex) then 
		create_lc(gvid,vertex)
		return "level:= level changer successfully created at your position from"..level_name.." to "..wrd.." (Spawning at first found gvid)"
	end
	--]]

	return "level:= there is no level changer between "..level_name.." and "..wrd
end

function cmd.warpall(me,txt,owner,p)
	local levels = utils_data.collect_section(game_ini(),"level_maps_single")
	if (levels[1]) then
		save_var(db.actor,"debug_warpall",1)
		_G.JumpToLevel(levels[1])
	end
	return "warpall := warping to every single level then flushing log"
end

-- dev_debug
function cmd.dev_debug(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[on | off]")
	if not (wrd) then return end
	if (wrd == "on") then
		_G.DEV_DEBUG = true
	elseif (wrd == "off") then
		_G.DEV_DEBUG = false
	end
	return "dev_debug:= type dev_debug help for list of sub commands."
end

-- game_graph
function cmd.game_graph(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[show | near | checkall]")
	if not (wrd) then return end

	if (wrd == "show") then
		local gg = game_graph()
		local vertex, level_name, lvid, pos, se_obj
		local sim = alife()
		local gvid = 0
		local lgvid = 0
		local level = level
		while gg:valid_vertex_id(gvid) do
			vertex = gg:vertex(gvid)
			level_name = alife():level_name(vertex:level_id())
			lvid = vertex:level_vertex_id()
			pos = vertex:level_point()

			se_obj = sim:create("medkit", pos, lvid, gvid)
			level.map_add_object_spot_ser(se_obj.id, "treasure", level_name.." Gvid:"..gvid)

			if (level_name == level.name()) then
				lgvid = lgvid + 1
			end
			gvid = gvid + 1
		end
		return "game_graph:= spots created. There are "..lgvid.." in "..level.name().." and "..gvid.." total."
	elseif (wrd == "near") then
		local gg = game_graph()
		local vertex, level_name, lvid, pos
		local near_lvid, near_dist, near_gvid, dist
		local gvid = 0
		local lgvid = 0
		local level = level
		while gg:valid_vertex_id(gvid) do
			vertex = gg:vertex(gvid)
			level_name = alife():level_name(vertex:level_id())
			if (level_name == level.name()) then
				pos = vertex:level_point()

				dist = db.actor:position():distance_to_sqr(pos)

				if not (near_dist) then
					near_gvid = gvid
					near_dist = dist
				end

				if (dist < near_dist) then
					near_gvid = gvid
					near_dist = dist
				end
				lgvid = lgvid + 1
			end
			gvid = gvid + 1
		end
		return "game_graph:= nearest gvid = " .. near_gvid .. " [dist = " .. near_dist .. "] There are "..lgvid.." in "..level.name().." and "..gvid.." total."
	elseif (wrd == "checkall") then
		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end
		local page = wrd ~= "" and tonumber(wrd) or 1
		
		local issues = {}
		local gg = game_graph()
		local vertex
		local sim = alife()
		for i=1,65534 do
			local se_obj = sim:object(i)
			if (se_obj) and not (gg:valid_vertex_id(se_obj.m_game_vertex_id)) then
				issues[#issues+1] = se_obj:name()
			end
		end
		
		if (#issues == 0) then 
			return "game_graph:= no issues found"
		end
		
		local sz = owner.console_size
		local page_count = math.ceil(#issues/sz)

		if (page > page_count) then
			return "game_graph:= Invalid page"
		end

		owner:SendOutput("game_graph:= list of objects with invalid game_vertex_ids [%s of %s]",page,page_count)
		owner:SendOutputList(issues,(page*sz)-sz,sz-1)
		return
	end
	return "game_graph:= type game_graph help for list of commands"
end

-- item
function cmd.item(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[list <page> ]")
	if not (wrd) then return end

	if (wrd == "list") then
		if not (se_item.registered_items) then
			return "item:= error no registered_items list"
		end

		wrd = ""
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1
		local sz = owner.console_size - 1

		if not (sz) or (sz == 0) then return "item:= error" end

		local list_sz = 0
		for k,v in pairs(se_item.registered_items) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "item:= Invaild page"
		end

		owner:SendOutput("item:= Registered Item List [%s of %s]",page,page_count)

		local a = {}
		for n in pairs(se_item.registered_items) do table.insert(a, n) end
		table.sort(a)

		local ind, out, k
		for i=1,sz do
			ind = (page*sz - sz) + i
			k = ind > 0 and a[ind]
			out = " "
			if (k) then
				out = string.format("%s [count: %s]",k,se_item.registered_items[k])
			end
			owner:SendOutput(out)
		end
		return
	end
	return "item:= type item help for a list of subcommands"
end

-- info
function cmd.info(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[list <page> | give | take | pas_b400 ]")
	if not (wrd) then return end

	if (wrd == "give") then
		give_info(rest)
		return "info:= info given"
	elseif (wrd == "take") then
		disable_info(rest)
		return "info:= disabled"
	elseif (wrd == "clear") then 
		local function itr(id,info)
			disable_info(info)
		end
		alife():iterate_info(0,itr)
		return "info:= all info portions removed from actor"
	elseif (wrd == "pas_b400") then
		give_info("pas_b400_task_given")
		give_info("pas_b400_underpass_start")
		give_info("pas_b400_sr_elevator_1_passed")
		give_info("pas_b400_canalisation_done")
		give_info("pas_b400_done")
		give_info("jup_b218_monolith_hired")
		give_info("pas_b400_elevator_done")
		give_info("pas_b400_sr_elevator_5")
		give_info("pas_b400_track_done")
		give_info("pas_b400_sr_track_4")
		give_info("pas_b400_downstairs_done")
		give_info("pas_b400_sr_downstairs_2")
		give_info("pas_b400_tunnel_done")
		give_info("pas_b400_snork_tunnel_4_attack")
		give_info("pas_b400_snork_tunnel_2_jumped")
		give_info("pas_b400_snork_tunnel_3_jumped")
		give_info("pas_b400_sr_tunnel_5_in")
		give_info("pas_b400_hall_done")
		give_info("pas_b400_hall_monolith_squad_dead")
		give_info("pas_b400_hall_monolith_snipers_dead")
		give_info("pas_b400_way_done")
		give_info("pas_b400_sr_way_2")
		give_info("pas_b400_canalisation_snork_rl_spawned")
		give_info("pas_b400_disabled_ui")
		give_info("jup_a10_vano_agree_go_und")
		give_info("leader_achievement_gained")
		give_info("jup_b218_soldier_hired")

		if (xr_conditions.squad_exist(db.actor,db.actor,{"jup_b15_zulus_squad"})) then
			xr_effects.create_squad_member(db.actor,db.actor,{"jup_b218_vano_in_suit","jup_b15_zulus_squad","jup_a6_jup_b218_squad_member_arrive_walk"})
			xr_effects.create_squad_member(db.actor,db.actor,{"pri_a15_sokolov_sci","jup_b15_zulus_squad","jup_a6_jup_b218_squad_member_arrive_walk"})
			xr_effects.create_squad_member(db.actor,db.actor,{"jup_b4_monolith_squad_leader_freedom_mon_skin","jup_b15_zulus_squad","jup_a6_jup_b218_squad_member_arrive_walk"})
		end
		return "info:= jupiter underpass info given to actor"
	end


	if (wrd == "list") then
		if not (xrs_debug_tools.actor_info) then
			return "info:= actor_info empty"
		end

		wrd = ""
		local _strt, _end = string.find(rest,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd ~= "" and tonumber(wrd) or 1

		local sz = owner.console_size-1

		if not (sz) or (sz == 0) then return "info:= error" end

		local list_sz = 0
		for k,v in pairs(xrs_debug_tools.actor_info) do
			list_sz = list_sz + 1
		end

		local page_count = math.ceil(list_sz/sz)
		if (page > page_count) then
			return list_sz > 0 and "info: nothing in list" or "info:= Invaild page"
		end

		owner:SendOutput("info:= Infoportions [%s of %s]",page,page_count)

		local a = {}
		for n in pairs(xrs_debug_tools.actor_info) do table.insert(a, n) end
		table.sort(a)

		local ind, out, k
		for i=1,sz do
			ind = (page*sz - sz) + i
			k = ind > 0 and a[ind]
			owner:SendOutput(k or " ")
		end
		return
	end
	return "info:= type info help for a list of subcommands"
end

-- cmd.inventory_owner
function cmd.inventory_owner(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[removeall]")
	if (wrd == "removeall") then 
		wrd = first_word(rest)
		if (wrd == "help") then 
			return "inventory_owner:= try 'inventory_owner removeall id:<number>'"
		end 
		
		local id
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end
		if not (id) then
			return "inventory_owner:= type 'inventory_owner removeall help'"
		end
		
		local sim = alife()
		local count = 0
		for i=1,65534 do 
			local se_obj = sim:object(i)
			if (se_obj and se_obj.parent_id == id) then 
				sim:release(se_obj,true)
				count = count + 1
			end
		end
		if (count > 0) then 
			return "inventory_owner:= removed %s children from inventory_owner",count
		end
		return "inventory_owner:= failed to remove any children from inventory_owner"
	end
	return "inventory_owner:= type 'inventory_owner help' for a list of subcommands"
end 

-- cmd.antifreeze
function antifreeze_switch(id)
	local sim = alife()
	local se_obj = sim:object(id)
	if not (se_obj) then 
		return true 
	end 
	if (se_obj:can_switch_offline()) then
		utils_obj.switch_offline(se_obj.id)
	elseif (se_obj:can_switch_online()) then
		utils_obj.switch_online(se_obj.id)
	end
	return true
end 
function cmd.antifreeze(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"[npc [<time>]] (ex.1: antifreeze 5 | ex.2: antifreeze npc 5)")
	
	local function tele_to_actor(id)
		local sim = alife()
		local se_obj = sim:object(id)
		if not (se_obj) then 
			return true 
		end
		local cls = se_obj:clsid()
		if (cls == clsid.online_offline_group_s) then
			TeleportSquad(se_obj,db.actor:position(),db.actor:level_vertex_id(),db.actor:game_vertex_id())
		elseif (IsStalker(nil,cls) or IsMonster(nil,cls)) then 
			if (alife().teleport_object) then 
				alife():teleport_object(se_obj,db.actor:game_vertex_id(),db.actor:level_vertex_id(),db.actor:position())
			end
		end
		return true
	end  
	
	local function repeater(a)
		CreateTimeEvent(a,"antifreeze",wrd,antifreeze_switch,a)
		return false
	end
	
	if (wrd == "npc") then 
		local _strt, _end = string.find(txt,"%d+")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		wrd = wrd ~= "" and tonumber(wrd) or 5

		se_obj = alife_create("sim_default_stalker_0", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
		if not (se_obj) then 
			return "antifreeze:= failed to create stalker "
		end
		CreateTimeEvent(se_obj.id,"repeater",10,repeater,se_obj.id)
	else 
		wrd = tonumber(wrd) or 5 
		
		if not (smart_terrain.nearest_to_actor_smart.id) then 
			return "antifreeze:= no nearest smart"
		end 
		
		local smart = alife_object(smart_terrain.nearest_to_actor_smart.id)
		if not (smart) then 
			return "antifreeze:= smart by id " .. smart_terrain.nearest_to_actor_smart.id .. "does not exist."
		end 
		
		local se_obj = SIMBOARD:create_squad(smart,"stalker_sim_squad_novice")
		if not (se_obj) then 
			return "antifreeze:= failed to create squad "
		end 
		
		se_obj.scripted_target = "actor"
		
		CreateTimeEvent(se_obj.id,"teleport",1,tele_to_actor,se_obj.id)
		CreateTimeEvent(se_obj.id,"repeater",1,repeater,se_obj.id)
	end
	
	return "antifreeze:= created object and teleported to your position!"
end 

function cmd.pstor_test(me,txt,owner,p)
	local wrd = check_and_set_help(me,txt,owner,"saves 2000 boolean to db.actor using pstor_store")
	if not (db.actor) then 
		return "pstor_test:= actor not present"
	end 
	
	for _ = 1, 2000 do
		local var = tostring( math.random() ):sub( 1, 10 )
		local val = tostring( math.random() ):sub( 1, 10 )
		printf("%s | %s",var,val)
		save_var( db.actor, var, val )
	end

	return "pstor_test:= successfully saved 2000 values to db.actor pstor"
end

debug_visuals = nil
function cmd.debug_visuals(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[all|<visual_name>]")
	if (wrd) and (wrd == "all" or wrd ~= "") then
		local check_all = wrd == "all"
		
		debug_visuals = {}
		
		local gvid = db.actor:game_vertex_id()
		local pos = db.actor:position()

		local dist = 1
		local f = getFS()
		local flist = f:file_list_open_ex("$game_meshes$",bit_or(FS.FS_ListFiles),"*.ogf")
		local f_cnt = flist:Size()
		for	it=0, f_cnt-1 do
			local file = flist:GetAt(it)
			local visual_name = file:NameFull():sub(1,-5)

			if (check_all or string.find(visual_name,wrd)) then
				if (string.find(visual_name,"actors\\") == 1 and not string.find(visual_name,"trader") and not string.find(visual_name,"lesnik")) then
					local newpos = vector():set(pos)
					newpos:add(vector():set(device().cam_dir):mul(dist))
					newpos = vector():set(newpos.x,pos.y,newpos.z)
					local lvid = level.vertex_id(newpos)
					local se_obj = alife_create("sim_default_stalker_0",newpos,lvid,gvid)
					if (se_obj) then
						alife_create_item("wpn_pkm", se_obj)
						--printf("%s visual:= %s",se_obj:name(),visual_name)
						debug_visuals[se_obj.id] = visual_name
					end
					dist = dist + 1
				end
			end
		end
		return "debug_visuals:= done!"
	end
	return "debug_visuals:= type debug_visuals help for a list of subcommands."
end

function cmd.gulag(me,txt,owner,p)
	local wrd,rest = check_and_set_help(me,txt,owner,"[export]")
	if (wrd) then
		if (wrd  == "export") then 
			local sim = alife()
			for i=1,65534 do
				local se_obj = sim:object(i)
				if se_obj and se_obj:clsid() == clsid.smart_terrain then 
					gulag_general.load_job(se_obj,true)
				end
			end
			return "gulag export done"
		end
	end
	return "gulag:= type gulag help for a list of subcommands."
end


-- Tronex
function cmd.alife_release(_,txt,x)
	local common = (txt == "common")
	local all = (txt == "all")
	local sim = alife()
	local c = 0
	for id,_ in pairs(SIMBOARD.squads) do
		local se_squad = sim:object(id)
		if se_squad then
			if common then
				--if (not get_object_story_id(id)) then
				if se_squad.common then
					se_squad:remove_squad()
					c = c + 1
				end
			elseif all then
				se_squad:remove_squad()
				c = c + 1
			end
		end
	end
	if c == 0 then
		--x:SendOutput('!Nothing is released dummy. Try (alife_release all) or (alife_release common)')
		x:SendOutput('!No squads found')
	else
		x:SendOutput('-Released %s stalkers and mutants: %s squads', txt, c)
	end
end

function cmd.alife_print_npc(_,txt,x)

-- alife_print_info all 			(print count of all npcs, works without stating "all" too)
-- alife_print_info human 			(print count of all humans, communities sorted)
-- alife_print_info human killer 	(print count of all humans that belong to mercs)
-- alife_print_info monster 		(print count of all mutants)

	local a = {}
	local b = split(txt) or {}
	if (not b[1]) then
		b[1] = "all"
	end
	
	local is_s = (b[1] == "human") or (b[1] == "all") or false
	local is_m = (b[1] == "monster") or (b[1] == "all") or false
	if (not is_s) and (not is_m) then
		return
	end
	
	local sim = alife()
	for i=1,65534 do 
		local se_obj = sim:object(i)
		if (se_obj and se_obj.group_id ~= nil and se_obj.group_id ~= 65535) then 
			if is_s and IsStalker(nil,se_obj:clsid()) then
				local comm = se_obj:community()
				if (not b[2]) or (b[2] and b[2] == comm) then
					a[comm] = a[comm] and (a[comm] + 1) or 1
				end
			elseif (not b[2]) and is_m and IsMonster(nil,se_obj:clsid()) then
				a["monster"] = a["monster"] and (a["monster"] + 1) or 1
			end
		end
	end
	
	local tot = 0
	x:SendOutput('___________________________________')
	for k,v in pairs(a) do
		tot = tot + v
		x:SendOutput('NPC count of %s: %s',k,v)
	end
	x:SendOutput('NPC count of %s: %s',txt,tot)
end

function cmd.alife_print_squad(_,txt,x)

-- alife_print_squad all 			(print count of all squads, works without stating "all" too)
-- alife_print_squad human 			(print count of all human squads, communities sorted)
-- alife_print_squad human killer 	(print count of all human squads that belong to mercs)
-- alife_print_squad monster 		(print count of all mutant squads)

	local a = {}
	local b = split(txt) or {}
	if (not b[1]) then
		b[1] = "all"
	end
	
	local is_s = (b[1] == "human") or (b[1] == "all") or false
	local is_m = (b[1] == "monster") or (b[1] == "all") or false
	if (not is_s) and (not is_m) then
		return
	end
	
	local sim = alife()
	for id,v in pairs( SIMBOARD.squads ) do
		local squad = sim:object(id)
		if (squad) then
			if (not b[2]) and is_m and (is_squad_monster[squad.player_id]) then
				a[squad.player_id] = a[squad.player_id] and (a[squad.player_id] + 1) or 1
			elseif is_s and (not is_squad_monster[squad.player_id]) and (not get_object_story_id(squad.id)) then
				if (not b[2]) or (b[2] and b[2] == squad.player_id) then
					a[squad.player_id] = a[squad.player_id] and (a[squad.player_id] + 1) or 1
				end
			end
		end
	end
	
	local tot = 0
	x:SendOutput('___________________________________')
	for k,v in pairs(a) do
		tot = tot + v
		x:SendOutput('Squad count of %s: %s',k,v)
	end
	x:SendOutput('Squad count of %s: %s',txt,tot)
end

function cmd.alife_report(_,txt,x)
	local alife_tbl = {}
	local clsid_tbl = {}
	local clsid_tbl_1 = {
		["actor"] = 90,
		["art_bast_artefact"] = 0,
		["art_black_drops"] = 1,
		["art_cta"] = 3,
		["art_dummy"] = 4,
		["art_electric_ball"] = 5,
		["art_faded_ball"] = 6,
		["art_galantine"] = 7,
		["art_gravi"] = 8,
		["art_gravi_black"] = 2,
		["art_mercury_ball"] = 9,
		["art_needles"] = 10,
		["art_rusty_hair"] = 11,
		["art_thorn"] = 12,
		["art_zuda"] = 13,
		["artefact"] = 41,
		["artefact_s"] = 102,
		["bloodsucker"] = 14,
		["bloodsucker_s"] = 108,
		["boar"] = 15,
		["boar_s"] = 109,
		["burer"] = 16,
		["burer_s"] = 110,
		["car"] = 52,
		["cat"] = 17,
		["cat_s"] = 111,
		["chimera"] = 29,
		["chimera_s"] = 112,
		["controller"] = 18,
		["controller_s"] = 113,
		["crow"] = 19,
		["destrphys_s"] = 93,
		["device_detector_advanced"] = 53,
		["device_detector_elite"] = 54,
		["device_detector_scientific"] = 57,
		["device_detector_simple"] = 58,
		["device_flare"] = 55,
		["device_pda"] = 56,
		["device_torch"] = 59,
		["device_torch_s"] = 146,
		["dog_black"] = 20,
		["dog_red"] = 23,
		["dog_s"] = 116,
		["equ_exo"] = 60,
		["equ_military"] = 61,
		["equ_scientific"] = 62,
		["equ_stalker"] = 63,
		["equ_stalker_s"] = 65,
		["equ_helmet_s"] = 70,
		["flesh"] = 24,
		["flesh_group"] = 25,
		["flesh_s"] = 117,
		["fracture"] = 26,
		["fracture_s"] = 119,
		["game_cl_artefact_hunt"] = 45,
		["game_cl_capture_the_artefact"] = 46,
		["game_cl_deathmatch"] = 47,
		["game_cl_single"] = 48,
		["game_cl_team_deathmatch"] = 49,
		["game_sv_artefact_hunt"] = 129,
		["game_sv_capture_the_artefact"] = 130,
		["game_sv_deathmatch"] = 131,
		["game_sv_single"] = 132,
		["game_sv_team_deathmatch"] = 133,
		["game_ui_artefact_hunt"] = 147,
		["game_ui_capture_the_artefact"] = 148,
		["game_ui_deathmatch"] = 149,
		["game_ui_single"] = 150,
		["game_ui_team_deathmatch"] = 151,
		["gigant_s"] = 118,
		["graph_point"] = 28,
		["hanging_lamp"] = 94,
		["helicopter"] = 50,
		["helmet"] = 64,
		["hlamp_s"] = 125,
		["hud_manager"] = 74,
		["inventory_box"] = 95,
		["inventory_box_s"] = 140,
		["level"] = 69,
		["level_changer"] = 84,
		["level_changer_s"] = 85,
		["main_menu"] = 86,
		["mp_players_bag"] = 87,
		["nogravity_zone"] = 211,
		["obj_antirad"] = 75,
		["obj_antirad_s"] = 135,
		["obj_attachable"] = 76,
		["obj_bandage"] = 77,
		["obj_bandage_s"] = 136,
		["obj_bolt"] = 78,
		["obj_bottle"] = 79,
		["obj_bottle_s"] = 137,
		["obj_breakable"] = 91,
		["obj_climable"] = 92,
		["obj_document"] = 80,
		["obj_explosive"] = 81,
		["obj_explosive_s"] = 138,
		["obj_food"] = 82,
		["obj_food_s"] = 139,
		["obj_medkit"] = 83,
		["obj_medkit_s"] = 142,
		["obj_pda_s"] = 144,
		["obj_phskeleton"] = 100,
		["obj_phys_destroyable"] = 99,
		["obj_physic"] = 96,
		["online_offline_group"] = 88,
		["online_offline_group_s"] = 89,
		["phantom"] = 30,
		["poltergeist"] = 31,
		["poltergeist_s"] = 120,
		["projector"] = 98,
		["pseudo_gigant"] = 27,
		["pseudodog_s"] = 121,
		["psy_dog"] = 22,
		["psy_dog_phantom"] = 21,
		["psy_dog_phantom_s"] = 114,
		["psy_dog_s"] = 115,
		["rat"] = 32,
		["script_actor"] = 134,
		["script_heli"] = 51,
		["script_object"] = 103,
		["script_phys"] = 97,
		["script_restr"] = 127,
		["script_stalker"] = 35,
		["script_zone"] = 101,
		["smart_cover"] = 104,
		["smart_terrain"] = 105,
		["smart_zone"] = 106,
		["smartcover_s"] = 107,
		["snork"] = 33,
		["snork_s"] = 122,
		["space_restrictor"] = 126,
		["spectator"] = 128,
		["stalker"] = 34,
		["team_base_zone"] = 214,
		["torrid_zone"] = 215,
		["trader"] = 36,
		["tushkano"] = 37,
		["tushkano_s"] = 123,
		["wpn_ak74"] = 173,
		["wpn_ak74_s"] = 152,
		["wpn_ammo"] = 39,
		["wpn_ammo_m209"] = 42,
		["wpn_ammo_m209_s"] = 141,
		["wpn_ammo_og7b"] = 43,
		["wpn_ammo_og7b_s"] = 143,
		["wpn_ammo_s"] = 40,
		["wpn_ammo_vog25"] = 44,
		["wpn_ammo_vog25_s"] = 145,
		["wpn_auto_shotgun_s"] = 153,
		["wpn_binocular"] = 174,
		["wpn_binocular_s"] = 154,
		["wpn_bm16"] = 175,
		["wpn_bm16_s"] = 155,
		["wpn_fn2000"] = 176,
		["wpn_fort"] = 177,
		["wpn_grenade_f1"] = 66,
		["wpn_grenade_f1_s"] = 67,
		["wpn_grenade_fake"] = 68,
		["wpn_grenade_launcher"] = 178,
		["wpn_grenade_launcher_s"] = 156,
		["wpn_grenade_rgd5"] = 71,
		["wpn_grenade_rgd5_s"] = 72,
		["wpn_grenade_rpg7"] = 73,
		["wpn_groza"] = 179,
		["wpn_groza_s"] = 157,
		["wpn_hpsa"] = 180,
		["wpn_hpsa_s"] = 158,
		["wpn_knife"] = 181,
		["wpn_knife_s"] = 159,
		["wpn_lr300"] = 182,
		["wpn_lr300_s"] = 160,
		["wpn_pm"] = 183,
		["wpn_pm_s"] = 161,
		["wpn_rg6"] = 184,
		["wpn_rg6_s"] = 162,
		["wpn_rpg7"] = 185,
		["wpn_rpg7_s"] = 163,
		["wpn_scope"] = 186,
		["wpn_scope_s"] = 164,
		["wpn_shotgun"] = 187,
		["wpn_shotgun_s"] = 165,
		["wpn_silencer"] = 188,
		["wpn_silencer_s"] = 166,
		["wpn_stat_mgun"] = 189,
		["wpn_svd"] = 190,
		["wpn_svd_s"] = 167,
		["wpn_svu"] = 191,
		["wpn_svu_s"] = 168,
		["wpn_usp45"] = 192,
		["wpn_usp45_s"] = 169,
		["wpn_val"] = 193,
		["wpn_val_s"] = 170,
		["wpn_vintorez"] = 194,
		["wpn_vintorez_s"] = 171,
		["wpn_walther"] = 195,
		["wpn_walther_s"] = 172,
		["wpn_wmagaz"] = 196,
		["wpn_wmaggl"] = 197,
		["zombie"] = 38,
		["zombie_s"] = 124,
		["zone"] = 216,
		["zone_acid_fog"] = 204,
		["zone_bfuzz"] = 205,
		["zone_bfuzz_s"] = 198,
		["zone_campfire"] = 206,
		["zone_dead"] = 207,
		["zone_galant_s"] = 199,
		["zone_galantine"] = 208,
		["zone_mbald_s"] = 200,
		["zone_mincer"] = 210,
		["zone_mincer_s"] = 201,
		["zone_mosquito_bald"] = 209,
		["zone_radio_s"] = 202,
		["zone_radioactive"] = 212,
		["zone_rusty_hair"] = 213,
		["zone_torrid_s"] = 203,
	}
		
	for k,v in pairs(clsid_tbl_1) do
		clsid_tbl[v] = k
	end

	local c = 0
	local sim = alife()

	for i=1, 65534 do
		local se_obj = sim:object(i)
		if (se_obj) then
			c = c + 1
			local cls = se_obj:clsid()
			local sec = se_obj:section_name()
			
			if (not alife_tbl[cls]) then
				alife_tbl[cls] = {}
			end
			alife_tbl[cls][sec] = alife_tbl[cls][sec] and (alife_tbl[cls][sec] + 1) or 1
			
		end
	end
	printf("-ALife total num of objects = %s",c)
	printf("--------------------------------------")
	
	
	printf("-ALife summery by class:")
	for k,v in pairs(alife_tbl) do
		local c = 0
		for k2,v2 in pairs(v) do c = c + v2 end
		printf("-cls[%s] = %s",clsid_tbl[k] or k,c)
	end
	printf("--------------------------------------")
	
	
	printf("-ALife full report by class and section:")
	for k,v in pairs(alife_tbl) do
		for k2,v2 in pairs(v) do
			printf("-cls[%s][%s] = %s",clsid_tbl[k] or k,k2,v2)
		end
	end
	printf("--------------------------------------")
	x:SendOutput('Done! see log')
end

function cmd.get_nearest_object(_,txt,x)
	local b = split(txt) or {}
	local dist,se_obj,obj
	local nearest_obj,nearest_dist
	local is_cam = b[1] == "cam"
	local pos = is_cam and device().cam_pos or db.actor:position()
	local sim = alife()
	
	for i=1, 65534 do
		se_obj = sim:object(i)
		if (se_obj and (se_obj.parent_id ~= AC_ID)) then -- avoid items in inventory
			obj = level.object_by_id(i)
			if obj then
				dist = pos:distance_to_sqr(obj:position())
				if not (nearest_dist) then
					nearest_dist = dist
					nearest_obj = obj
				end

				if (dist < nearest_dist) then
					nearest_dist = dist
					nearest_obj = obj
				end
			end
		end
	end
	
	if nearest_obj then
		x:SendOutput('---------------------')
		x:SendOutput('-Nearest object found: %s', nearest_obj:name())
		x:SendOutput('-Section: %s', nearest_obj:section())
		x:SendOutput('-ID: %s', nearest_obj:id())
		x:SendOutput('-Distance: %s', nearest_dist^0.5)
	else
		x:SendOutput('!No online object is found')
	end
end

function cmd.get_npc_visual(_,__,x)
	local npc, dist = utils_obj.get_nearest_stalker("cam")
	if (not npc) then
		x:SendOutput('-No NPC found')
		return
	end
	
	local id = npc:id()
	local name = npc:character_name()
	local comm = npc:character_community()
	local visual = npc:get_visual_name()
	
	x:SendOutput('- Nearest NPC')
	x:SendOutput('/ Distance: %s',dist)
	x:SendOutput('/ id: %s',id)
	x:SendOutput('/ Name: %s',name)
	x:SendOutput('/ Community: %s',comm)
	x:SendOutput('/ Visual: %s',visual)
	
	printf('- Nearest NPC')
	printf('/ Distance: %s',dist)
	printf('/ id: %s',id)
	printf('/ Name: %s',name)
	printf('/ Community: %s',comm)
	printf('/ Visual: %s',visual)
end

function cmd.surge(_,txt,x)
	if (txt == "start") and (surge_manager.is_finished()) then
		surge_manager.start_surge()
		x:SendOutput('Surge has started')
	elseif (txt == "stop") and (surge_manager.is_started()) then
		surge_manager.stop_surge()
		x:SendOutput('Surge has stopped')
	end
end

function cmd.psi_storm(_,txt,x)
	if (txt == "start") and (psi_storm_manager.is_finished()) then
		psi_storm_manager.start_psi_storm()
		x:SendOutput('Psi-storm has started')
	elseif (txt == "stop") and (psi_storm_manager.is_started()) then
		psi_storm_manager.stop_psi_storm()
		x:SendOutput('Psi-storm has stopped')
	end
end

function cmd.ppe_effect(_,txt,x)
	local b = split(txt) or {}
	
	if b[1] and level.present() and (db.actor ~= nil) and db.actor:alive() then
		if (b[1] == "play") and b[2] then
			level.remove_pp_effector(2009)
			level.add_pp_effector(b[2] .. ".ppe", 2009, true)
		elseif b[2] == "stop" then
			level.remove_pp_effector(2009)
		end
	end
end

function cmd.set_rank(_,txt,x)
	local rank = txt and tonumber(txt)
	if rank and (rank > 0) and (rank < 56000) then
		db.actor:set_character_rank(rank)
		local str = strformat("Actor rank is now: %s",rank)
		x:SendOutput(str)
	end
end

function cmd.set_rep(_,txt,x)
	local rept = txt and tonumber(txt)
	if rept and (rept > -4000) and (rept < 4000) then
		db.actor:set_character_reputation(rept)
		local str = strformat("Actor reputation is now: %s",rept)
		x:SendOutput(str)
	end
end

function cmd.get_nearby_companion(_,txt,x)
	local npc, dist = utils_obj.get_nearest_stalker("cam")
	if (not npc) then
		x:SendOutput('-No NPC found')
		return
	end
	
	local name = npc:name()
	
	if (not dialogs_axr_companion.is_non_story(nil,npc)) then
		x:SendOutput('![%s] is a story NPC',name)
		return
	end
	if (not dialogs_axr_companion.is_not_actor_companion(nil,npc)) then
		x:SendOutput('![%s] is already a companion',name)
		return
	end
	if (not dialogs_axr_companion.is_room_in_actor_squad(nil,npc)) then
		x:SendOutput('!you dont have more room for another companion',name)
		return
	end
	if (not dialogs_axr_companion.is_not_hostage_task_giver(db.actor,npc)) then
		x:SendOutput('![%s] is a hostage',name)
		return
	end
	
	dialogs_axr_companion.become_actor_companion(db.actor,npc)
	
	x:SendOutput('![%s] squad become companions',name)
end

function cmd.map_marker(_,txt,x)
	local b = split(txt) or {}
	if not (b[1] and b[2]) then
		return
	end
	local add = b[1] == "add" and true or false
	local remov = b[1] == "remove" and true or false
	local id = tonumber(b[2])
	if (add or remov) and (type(id) == "number") and (id > 0) and (id < 65535) then
		local se_obj = alife_object(id)
		local obj = level.object_by_id(id)
		local name = (se_obj and se_obj:section_name()) or (obj and obj:section()) or ""
		if name ~= "" then
			if add then
				local str = "Marked\\nsection: " .. name .. "\\nid: " .. tostring(id)
				level.map_add_object_spot_ser(id, "secondary_task_location", str)
				x:SendOutput("Map marker for id: " .. id .. "has been added!")
				return
			else
				level.map_remove_object_spot(id, "secondary_task_location")
				x:SendOutput("Map marker for id: " .. id .. "has been removed!")
				return
			end
		end
	end
	return
end

function cmd.scan_item_configs(_,txt,x)
	x:SendOutput("scan_item_configs")
	local scan_uses = (txt == "uses") and true or false
		
	local sfind = string.find
	local exclude = {
		["spawn_by_story_id"] = true,
		["trader"] = true,
		["discount_0"] = true,
		["discount_1"] = true,
		["discount_2"] = true,
		["discount_3"] = true,
		["discount_4"] = true,
		["discount_5"] = true,
		["discount_6"] = true,
		["discount_7"] = true,
		["discount_8"] = true,
		["discount_9"] = true,
		["discount_10"] = true,
		["discount_trasher_1"] = true,
		["discount_trasher_ld_1"] = true,
		["discount_supplier_1"] = true,
		["discount_barman_1"] = true,
		["discount_barman_ld_1"] = true,
		["discount_neutral_1"] = true,
		["discount_special_1"] = true,
		["discount_extra_1"] = true,
		["mutant_loot_mod"] = true,
		["mutant_loot_drop_sections"] = true,
	}
	
	local function scan_file(path)
		printf("--------------------------------------------")
		printf("~scan_item_configs | target file: %s", path)
		local ltx = ini_file(path)
		ltx:section_for_each(function(section)
			if (not exclude[section]) then
				local n = ltx:line_count(section)
				local result, id, value = "", "", ""
				for i=0,n-1 do
					result, id, value	= ltx:r_line_ex(section,i,"","")
					if id then
						local sec, uses = utils_item.get_defined_uses(id)
						if (not ini_sys:section_exist(sec)) then
							printf("!LTX SCAN: %s: [%s]->[%s] invalid", path, section, sec)
						elseif scan_uses and (not uses) and (ini_sys:r_bool_ex(sec,"use_condition")) and (ini_sys:r_float_ex(sec,"max_uses")) then
							printf("!LTX SCAN: %s: [%s]->[%s] lack uses", path, section, sec)
						end
					end
				end
			end
		end)
	end
	
	local all_pathes = {}
	local fileList = getFS():file_list_open("$game_config$", "items\\trade\\", bit_or(FS.FS_ListFiles, FS.FS_RootOnly))
	local count = fileList and fileList:Size() or 0
	if count > 0 then
		for i = 1, count do
			local file_name = fileList:GetAt(i - 1):sub(1, -5)
			if file_name then
				all_pathes[#all_pathes + 1] = "items\\trade\\" .. file_name .. ".ltx"
			end
		end
	end
	
	all_pathes[#all_pathes + 1] =  "items\\settings\\ph_box_generic.ltx"
	all_pathes[#all_pathes + 1] =  "items\\settings\\treasure_manager.ltx"
	--all_pathes[#all_pathes + 1] =  "items\\settings\\mutant_loot.ltx"
	all_pathes[#all_pathes + 1] =  "items\\settings\\death_generic.ltx"
	
	for i=1,#all_pathes do
		scan_file(all_pathes[i])
	end
	
	return
end

function cmd.scan_unused_weapons(_,txt,x)
	x:SendOutput("scan_unused_weapons")
	
	local sfind = string.find
	
	local weapon_secs = {}
	local weapon_classes = {
		["WP_KNIFE"]    = true,
		["WP_HPSA"]     = true,
		["WP_PM"]       = true,
		["WP_ASHTG"]    = true,
		["WP_BM16"]     = true,
		["WP_AK74"]     = true,
		["WP_GROZA"]    = true,
		["WP_LR300"]    = true,
		["WP_VAL"]      = true,
		["WP_SVD"]      = true,
		["WP_SVU"]      = true,
		["WP_RG6"]      = true,
		["WP_RPG7"]     = true,
		["G_F1_S"]      = true,
		["G_RGD5_S"]    = true,
		["G_F1"] 	    = true,
		["G_RGD5"] 	    = true,
	}
	
	ini_sys:section_for_each(function(section)
		local cls = ini_sys:r_string_ex(section,"class") or ""
		if cls and cls ~= ""
		and weapon_classes[cls]
		and (not sfind(section,"hud"))
		and (not sfind(section,"1p29"))
		and (not sfind(section,"kobra"))
		and (not sfind(section,"ps01"))
		and (not sfind(section,"ac10632"))
		and (not sfind(section,"ac11090"))
		and (not sfind(section,"eot"))
		and (not sfind(section,"acog"))
		and (not sfind(section,"c-more"))
		then
			weapon_secs[section] = true
		end
	end)
	
	--------------------------------------------------------------------------------
	
	local function scan_trader_file(path)
		printf("~scan_trader_configs | target file: %s", path)
		local ltx = ini_file(path)
		ltx:section_for_each(function(section)
			if sfind(section,"supplies_") then
				local n = ltx:line_count(section)
				local result, id, value = "", "", ""
				for i=0,n-1 do
					result, id, value	= ltx:r_line_ex(section,i,"","")
					if value and weapon_secs[id] then
						weapon_secs[id] = nil
					end
				end
			end
		end)
	end
	
	local all_trader_pathes = {}
	local fileList = getFS():file_list_open("$game_config$", "items\\trade\\", bit_or(FS.FS_ListFiles, FS.FS_RootOnly))
	local count = fileList and fileList:Size() or 0
	if count > 0 then
		for i = 1, count do
			local file_name = fileList:GetAt(i - 1):sub(1, -5)
			if file_name then
				all_trader_pathes[#all_trader_pathes + 1] = "items\\trade\\" .. file_name .. ".ltx"
			end
		end
	end

	for i=1,#all_trader_pathes do
		scan_trader_file(all_trader_pathes[i])
	end
	
	--------------------------------------------------------------------------------
	
	local function scan_ai_file(path)
		printf("~scan_ai_configs | target file: %s", path)
		local ltx = ini_file(path)
		local str_ex = str_explode
		ltx:section_for_each(function(section)
			local n = ltx:line_count(section)
			local result, id, value = "", "", ""
			for i=0,n-1 do
				result, id, value	= ltx:r_line_ex(section,i,"","")
				local t = str_ex(id,":")
				if t and t[1] and weapon_secs[t[1]] then
					weapon_secs[id] = nil
				end
			end
		end)
	end
	--scan_ai_file("ai_tweaks\\xrs_rnd_npc_loadout.ltx")
	
	--------------------------------------------------------------------------------
	
	printf("~List of weapons that don't exist in traders profiles")
	for k,v in pairs(weapon_secs) do
		printf("/ [%s]",k)
	end
	
	return
end

function cmd.scan_unused_icons(_,txt,x)
	x:SendOutput("scan_unused_icons")
	
	local sfind = string.find
	local icons = {}
	
	-- Read all icons
	ini_sys:section_for_each(function(section)
		local x = ini_sys:r_float_ex(section,"inv_grid_x")
		if x then
			local y = ini_sys:r_float_ex(section,"inv_grid_y")
			local w = ini_sys:r_float_ex(section,"inv_grid_width") or 1
			local h = ini_sys:r_float_ex(section,"inv_grid_height") or 1
			icons[section] = { x = x , y = y , w = w , h = h}
		end
	end)
	
	printf("-sections total: %s", table_size(icons))
	
	-- Removed sections with duplicated pos
	local to_remove = {}
	for k,v in pairs(icons) do
		if (not to_remove[k]) then
			for k2,v2 in pairs(icons) do
				if (k ~= k2) and (v.x == v2.x) and (v.y == v2.y) then
					to_remove[k2] = true
				end
			end
		end
	end
	for k,v in pairs(icons) do
		if to_remove[k] then
			icons[k] = nil
		end	
	end
	
	printf("-sections finale: %s", table_size(icons))
	printf("-duplicated sections to remove: %s", table_size(to_remove))
	
	-- Gather all used 50,50 squares
	local us = {}
	for k,v in pairs(icons) do
		for i=1,(v.w) do
			for j=1,(v.h) do
				local x = v.x + (i-1)
				local y = v.y + (j-1)
				if (not us[x]) then us[x] = {} end
				us[x][y] = true
			end
		end
		
	end
	
	-- Gather all unused 50,50 squares
	local unused = {}
	for i=1,164 do -- x
		for j=1,82 do -- y
			local x = i-1
			local y = j-1
			if not (us[x] and us[x][y]) then
				unused[#unused + 1] = {x = x , y = y}
			end
		end
	end
	
	-- Print
	printf("-unused size: %s", #unused)
	for i=1,#unused do
		printf("x = %s , y = %s", unused[i].x, unused[i].y)
	end
	
	return
end

function cmd.scan_unused_level_logic(_,txt,x)
	x:SendOutput("scan_unused_level_logic")
	if not (txt) then return end
	
	local map = txt
	local sfind = string.find

	local function collect_files(path)
		local fileList = getFS():file_list_open("$game_config$", "scripts\\" .. path, bit_or(FS.FS_ListFiles, FS.FS_RootOnly))
		local count = fileList and fileList:Size() or 0
		local tbl = {}
		if count > 0 then
			for i = 1, count do
				local file_name = fileList:GetAt(i - 1):sub(1, -5)
				if file_name then
					tbl[#tbl + 1] = path .. file_name .. ".ltx"
				end
			end
			return tbl
		end
	end
	
	local logic_files = collect_files(map .. "\\")
	local smart_files = collect_files(map .. "\\smart\\")
	
	local lgc = {}
	for i=1,#logic_files do
		lgc[logic_files[i]] = true
	end
	
	-- remove used files out of table
	for i=1,#smart_files do
		local smart_ini = ini_file("scripts\\" .. smart_files[i])
		smart_ini:section_for_each(function(section)
			if section == "exclusive" then
				local n = smart_ini:line_count(section)
				local result, id, value = "", "", ""
				for i=0,n-1 do
					result, id, value	= smart_ini:r_line_ex(section,i,"","")
					if value and lgc[value] then
						lgc[value] = nil
					end
				end
			end
		end)
	end
	
	-- remove files with space restrictor/pysical objects out of table
	for k,v in pairs(lgc) do
		local logic_ini = ini_file("scripts\\" .. k)
		logic_ini:section_for_each(function(section)
			if sfind(section,"sr_") or sfind(section,"ph_") then
				lgc[k] = nil
			end
		end)
	end
	
	-- to delet
	printf("~Unused logic files for %s:",map)
	for k,v in pairs(lgc) do
		printf(k)
	end
	
	return
end

function get_stat_value(obj, section, stat_type, type)
	local gr = utils_ui.stats_table[stat_type][type]
	local v = tonumber(utils_ui.get_stats_value(obj, section, gr, type) or 0)
	local m = gr["magnitude"]
	local result = v * m
	return result
end

function get_outfit_stat_value(obj, section, type)
	return get_stat_value(obj, section, "outfit", type)
end

function get_artefact_stat_value(obj, section, type)
	return get_stat_value(obj, section, "artefact", type)
end

function get_booster_stat_value(obj, section, type)
	return get_stat_value(obj, section, "booster", type)
end

function get_weapon_stat_value(obj, section, type)
	return get_stat_value(obj, section, "weapon", type)
end

function to_percent_string(value)
	return (value or 0) .. "%"
end

function to_percent_floor(value)
	return to_percent_string(math.floor(value))
end

function to_percent_round(value)
	return to_percent_string(round(value))
end

function decimal_to_percent(value)
	return to_percent_floor(tonumber(value) * 100)
end

function write_file(file, text,...)
	if not text then return end

	local i = 0
	local p = {...}
	local function sr(a)
		i = i + 1
		return tostring(p[i])
	end
	local output = string.gsub(text,"%%s",sr)
	file:write(output.."\n")
end

function get_outfit_repair_label(repair_type)
	if repair_type == "outfit_novice" then
		return "F"
	elseif repair_type == "outfit_light" or repair_type == "helmet_light" then
		return "L"
	elseif repair_type == "outfit_medium" or repair_type == "helmet_medium" then
		return "M"
	elseif repair_type == "outfit_heavy" or repair_type == "helmet_heavy" then
		return "H"
	elseif repair_type == "outfit_exo" or repair_type == "helmet_exo"then
		return "E"
	end
	return "N/A"
end

function cmd.export_outfits(_, txt, x)
	x:SendOutput("[START] export outfit")

	local outfit_cls = {
		["o_helmet"]    = true,
		["E_HLMET"]     = true,
		["EQU_HLMET"]   = true,

		["o_light"]     = true,

		["E_STLK"]      = true,
		["EQU_STLK"]    = true,
		["o_medium"]    = true,
		["o_sci"]       = true,

		["o_heavy"]     = true,
	}

	local outfit_type = {
		["helmet"]              =  1 ,
		["helmet_light"]        =  2 ,
		["outfit"]              =  3 ,
		["outfit_novice"]       =  4 ,
		["outfit_trenchcoat"]   =  5 ,
		["outfit_sunrise"]      =  6 ,
		["outfit_lcs"]          =  7 ,
		["outfit_explorer"]     =  8 ,
		["outfit_sts"]          =  9 ,
		["outfit_ps5"]          =  10,
		["outfit_nbc"]          =  11,
		["outfit_assault_vest"] =  12,
		["outfit_seva"]         =  13,
		["outfit_ssp"]          =  14,
		["outfit_berill"]       =  15,
		["outfit_skat"]         =  16,
		["outfit_exolight"]     =  17,
		["outfit_proto_exo"]    =  18,
		["outfit_exoskeleton"]  =  19,
		["outfit_nosorog"]      =  20,
	}

	local blacklist = {
		["outfit_base"] = true,
		["without_outfit"] = true,
		["tch_helmet"] = true,
		["mp_scientific_outfit"] = true,

	}
	local tbl = {}
	local cnt = 0
	local counter = 0
	local leftovers = {}
	ini_sys:section_for_each(function(section)
		if blacklist[section] or is_multiplayer_item(section) then
			return
		end
		local class = ini_sys:r_string_ex(section, "class")
		local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing

		--x:SendOutput("export outfit - %s, kind %s", section, kind)
		if kind then
			class = kind
		end
		if class and outfit_cls[class] then
			local pos = db.actor:position()
			local lvid = db.actor:level_vertex_id()
			local gvid = db.actor:game_vertex_id()
			local id = AC_ID

			local se_obj
			se_obj = alife_create_item(section, {pos, lvid, gvid, id} )

			if not se_obj then
				printf( "No server object made for [%s]", section)
				--x:SendOutput( "No server object made for [%s]", section)
				return
			end
			cnt = cnt + 1
			counter = counter + 1
			local repair_type = ini_sys:r_string_ex(section, "repair_type") or "na"
			if kind == "o_helmet" then
				repair_type = "outfit_helmet"
			elseif repair_type == "outfit_exo" then
				repair_type = "outfit_heavy"
			elseif repair_type == "outfit_novice" then
				repair_type = "outfit_light"
			end
			if not tbl[repair_type] then
				tbl[repair_type] = {}
			end
			local id = se_obj.id

			leftovers[section] = true
			x:SendOutput("export outfit - %s, start", section)
			local function createInterval(section, id, callback)
				CreateTimeEvent("export_outfit_"..section, "delay_func", 2, function(section, id)
					local success = callback(section, id)
					if not success then
						createInterval(section, id, callback)
					end
					return true
				end, section, id)
			end

			createInterval(section, id, function(section, id)
				local obj = level.object_by_id(id)
				if not obj then
					--x:SendOutput("export outfit - %s, still online", section)
					return false
				end

				--x:SendOutput("export outfit - %s, back offline", section)
				local outfit = {}
				outfit.typ = repair_type
				outfit.indx = outfit_type[repair_type] or 0
				outfit.faction = game.translate_string(ini_sys:r_string_ex(section, "community")) or "Unknown"
				outfit.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name")) or ""
				local rt = ini_sys:r_string_ex(section, "repair_type")
				--printf("export outfit - %s, repair type %s", section, rt)
				outfit.repair_label = get_outfit_repair_label(rt)

				outfit.cost = ini_sys:r_float_ex(section, "cost") or 0
				outfit.weight = math.floor(ini_sys:r_float_ex(section, "inv_weight") or 0)
				outfit.carry_weight = get_outfit_stat_value(obj, section, "additional_inventory_weight")
				outfit.arty = get_outfit_stat_value(obj, section, "artefact_count") or 0
				local max_arty = outfit.arty

				local tree = utils_item.get_upgrades_tree(section)
				for row, v in pairs(tree) do
					for col, w in pairs(v) do
						if w.prop[1] == "prop_artefact" then
							max_arty = max_arty + 1
						end
					end
				end

				outfit.max_arty = max_arty
				outfit.burn = to_percent_floor(get_outfit_stat_value(obj, section, "burn_protection"))
				outfit.shock = to_percent_floor(get_outfit_stat_value(obj, section, "shock_protection"))
				outfit.radiation = to_percent_floor(get_outfit_stat_value(obj, section, "radiation_protection"))
				outfit.chemical_burn = to_percent_floor(get_outfit_stat_value(obj, section, "chemical_burn_protection"))
				outfit.telepatic = to_percent_floor(get_outfit_stat_value(obj, section, "telepatic_protection"))
				outfit.impact = to_percent_floor(get_outfit_stat_value(obj, section, "strike_protection"))
				outfit.explosion = to_percent_floor(get_outfit_stat_value(obj, section, "explosion_protection"))
				outfit.rupture = to_percent_floor(get_outfit_stat_value(obj, section, "wound_protection"))
				outfit.ballistic = to_percent_floor(get_outfit_stat_value(obj, section, "fire_wound_protection"))
				outfit.br_class = round(get_outfit_stat_value(obj, section, "apres_modifier"))

				outfit.powered = item_exo_device.is_exo(obj) and "Y" or "N"

				outfit.speed = decimal_to_percent(outfit_speed_mcm.get_outfit_speed(obj, section, false))

				tbl[repair_type][section] = outfit
				alife_release(se_obj)
				x:SendOutput("export outfit - %s, done", section)
				counter = counter - 1
				leftovers[section] = nil
				return true
			end)
		end
	end)

	local function createTotalInterval(callback)
		CreateTimeEvent("export_outfits_total", "delay_func", 5, function()
			local success = callback()
			if not success then
				createTotalInterval(callback)
			end
			return true
		end)
	end

	createTotalInterval(function()
		if counter > 0 then
			x:SendOutput("export outfit - %s outfits still to do", counter)
			for section, _ in pairs(leftovers) do
				if section then
					x:SendOutput("export outfit - %s still to do", section)
				end
			end
			return false
		end

		local functor = function(t,a,b) return t[a].indx < t[b].indx end
		for repair_type, outfits in pairs(tbl) do
			local type_cnt = 0
			local p_file = "export_outfits_" .. repair_type .. ".csv"
			local debug_file = io.open(p_file,"w+")

			if ( debug_file == nil ) then
				x:SendOutput("Failed to create/open file %s", p_file)
				debug_file:close()
				return true
			end

			if repair_type == "outfit_helmet" then
				--csv header
				--write_file(debug_file, ~,     Name,   Repair Label,   Base Cost, Ballistic Res., BR Class,   Burn Res., Electrical Res., Chemical Res.,   Ext. Radiation Res., Psychic Res., Rupture Res., Impact Res., Explosive Res., Weight kg")
				for section,v in spairs(outfits, functor) do
					write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
					--~,     Name,   Repair Label,   Base Cost, Ballistic Res., BR Class,   Burn Res., Electrical Res., Chemical Res.,   Ext. Radiation Res., Psychic Res., Rupture Res., Impact Res., Explosive Res., Weight kg"
					section, v.name, v.repair_label, v.cost,    v.ballistic,    v.br_class, v.burn,    v.shock,         v.chemical_burn, v.radiation,         v.telepatic,  v.rupture,    v.impact,    v.explosion,    v.weight)
					type_cnt = type_cnt + 1
				end
			else
				--csv header
				--write_file(debug_file, "~,       Faction,   Name,   Base Cost,Powered,   Ballistic Res.,BR Class,   Burn Res., Electrical Res., Chemical Res.,   Ext. Radiation Res., Psychic Res., Rupture Res., Impact Res., Explosive Res., Incl. Belt Slots, Max Belt Slots, Weight Carried kg, Movespeed Mult., Weight kg")
				for section,v in spairs(outfits, functor) do
					write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
					--~,       Faction,   Name,   Repair Label,   Base Cost,Powered,   Ballistic Res.,BR Class,   Burn Res., Electrical Res., Chemical Res.,   Ext. Radiation Res., Psychic Res., Rupture Res., Impact Res., Explosive Res., Incl. Belt Slots, Max Belt Slots, Weight Carried kg, Movespeed Mult., Weight kg"
							section, v.faction, v.name, v.repair_label, v.cost,   v.powered, v.ballistic,   v.br_class, v.burn,    v.shock,         v.chemical_burn, v.radiation,         v.telepatic,  v.rupture,    v.impact,    v.explosion,    v.arty,           v.max_arty,     v.carry_weight,    v.speed,         v.weight)
					type_cnt = type_cnt + 1
				end
			end
			debug_file:close()
			x:SendOutput("[END] export outfit - %s outfits exported - see %s", type_cnt, p_file)
		end

		x:SendOutput("[END] export outfit - %s total outfits exported - see in Gamma\\Overwrite\\bin", cnt)
		return true
	end)
end

function file_exists(name)
	local f = io.open(name, "r")
	if f ~= nil then
		io.close(f)
		return true
	else
		return false
	end
end

function get_local_val(path, script_name, str_to_find)
	if _G[script_name] then

		if not file_exists(path) then
			return
		end

		for line in io.lines(path) do
			if string.find(line, str_to_find) then
				_,_, loc_val = string.find(line, "start_blur_4%s*=%s*(%d+)")		-- RavenAscendant carried
				if type(tonumber(loc_val)) == "number" then
					return loc_val
				end
			end
		end
	end
end

function getEatableSleepiness(section)
	local eat_sleepiness = ini_sys:r_float_ex(section, "eat_sleepiness")
	local eat_sleep_ex = eat_sleepiness and eat_sleepiness ~= 0

	if not eat_sleep_ex then
		return 0
	end

	local max_sleep = get_local_val([[gamedata\scripts\actor_status_sleep.script]], "actor_status_sleep", "local start_blur_4") or 8750
	local sleep_mult = get_local_val([[gamedata\scripts\actor_status_sleep.script]], "actor_status_sleep", "local eat_sleepiness_mul") or 1000
	eat_sleepiness = eat_sleepiness * sleep_mult
	local sleep_num = eat_sleepiness / max_sleep * 100
	return sleep_num
end

function getEatableThirstiness(section)
	local eat_thirstiness = ini_sys:r_float_ex(section, "eat_thirstiness")
	local eat_thirst_ex = eat_thirstiness and eat_thirstiness ~= 0

	if not eat_thirst_ex then
		return 0
	end

	local max_thirst = get_local_val([[gamedata\scripts\actor_status_thirst.script]], "actor_status_thirst", "local start_blur_4") or 5760
	local thirst_mult = get_local_val([[gamedata\scripts\actor_status_thirst.script]], "actor_status_thirst", "local eat_thirstiness_mul") or 1000
	eat_thirstiness = eat_thirstiness * thirst_mult
	local thirst_num = eat_thirstiness / max_thirst * 100
	return thirst_num
end

local rad_max = 3870
function getEatableRadiation(section)
	local eat_rad = ini_sys:r_float_ex(section, "eat_radiation")
	local eat_rad_ex = eat_rad and eat_rad ~= 0

	if not eat_rad_ex then
		return 0
	end

	local rad_num = eat_rad * rad_max
	return rad_num
end

function getSatietyPercent(flat_satiety)
	--local conditions = db.actor:cast_Actor():conditions()
	--local red_icon_satiety = conditions:SatietyCritical() * 0.5
	local red_icon_satiety = 0
	local max_satiety = 1 - red_icon_satiety
	local sat_num = flat_satiety / max_satiety * 100
	return sat_num
end

function getEatableSatiety(section)
	local eat_sat = ini_sys:r_float_ex(section, "eat_satiety")
	local eat_sat_ex = eat_sat and eat_sat ~= 0

	if not eat_sat_ex then
		return 0
	end

	return getSatietyPercent(eat_sat)
end

--See item_cooking.script::UICook:Load_MealRecipes
function getEatablesUsedInCooking()
	local used_in_cooking = {}
	local from_cooking = {}
	local cooking_ini = ini_file("items\\settings\\cook.ltx")
	n = cooking_ini:line_count("meal_list")
	for i=0,n-1 do
		result, id, value = cooking_ini:r_line_ex("meal_list",i,"","")
		if id and value then
			id = string.sub(id,3)
			if ini_sys:section_exist(id) then
				local t = str_explode(value,",")
				local food = tostring(t[3])
				if ini_sys:section_exist(food) then
					used_in_cooking[food] = true
				end
				from_cooking[id] = true
			end
		end
	end
	return used_in_cooking, from_cooking
end

function getEatableAlcohol(section)
	local eat_alcohol = ini_sys:r_float_ex(section, "eat_alcohol")
	local eat_alc_ex = eat_alcohol and eat_alcohol ~= 0

	if not eat_alc_ex then
		return 0
	end

	return eat_alcohol * 100
end

function cmd.export_eatable(_, txt, x)
    x:SendOutput("[START] export eatable")

    local food_kinds = {
        ["i_mutant_raw"] = true,
        ["i_mutant_cooked"] = true,
        ["i_drink"] = true,
		["i_mutant_cooked"] = true,
		["i_mutant_raw"] = true,
		["i_food"] = true,
		["II_FOOD"] = true,
		["S_FOOD"] = true,
		["i_drink"] = true,
		["II_BOTTL"] = true,
    }

	local blacklist = {
		["items_anm_dummy"] = true,
		["itm_xcvb_1"] = true,
		["itm_xcvb_2"] = true,
		["itm_xcvb_3"] = true,
		["vodka_script"] = true,
		["mutant_part_general_meat"] = true,
		["mp_energy_drink"] = true,
	}

	local used_in_cooking, from_cooking = getEatablesUsedInCooking()

    local tbl = {}
    local cnt = 0
    ini_sys:section_for_each(function(section)
		if blacklist[section] then
			return
		end
        local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing

        if kind and food_kinds[kind] then
            x:SendOutput("export eatable - %s", section)
			local eatable = {}
			eatable.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name")) or ""
			eatable.cost = ini_sys:r_float_ex(section, "cost") or 0
			eatable.weight = ini_sys:r_float_ex(section, "inv_weight") or 0
			eatable.tier = ini_sys:r_float_ex(section, "tier") or 0
			eatable.sleepiness = to_percent_string(getEatableSleepiness(section))
			eatable.thirstiness = to_percent_floor(getEatableThirstiness(section))
			eatable.alcohol = to_percent_floor(getEatableAlcohol(section))
			eatable.health = to_percent_string((ini_sys:r_float_ex(section, "eat_health") or 0) * 100)
			eatable.rads = math.floor(getEatableRadiation(section))
			eatable.satiety = to_percent_floor(getEatableSatiety(section))
			eatable.servings = ini_sys:r_float_ex(section, "max_uses") or 1
			eatable.used_in_cooking = used_in_cooking[section] and "Y" or "N"
			eatable.from_cooking = from_cooking[section] and "Y" or "N"

			eatable.duration = get_booster_stat_value(nil, section, "boost_time") or 0

			eatable.health_restore = get_booster_stat_value(nil, section, "boost_health_restore") or 0
			eatable.total_health_restore = to_percent_floor(eatable.duration * eatable.health_restore)
			eatable.health_restore = to_percent_string(eatable.health_restore)

			eatable.bleed_restore = (get_booster_stat_value(nil, section, "boost_bleeding_restore") or 0)/1000
			eatable.total_bleed_restore = eatable.duration * eatable.bleed_restore

			eatable.rad_restore = math.floor(get_booster_stat_value(nil, section, "boost_radiation_restore") or 0)
			eatable.total_rad_restore = math.floor(eatable.duration * eatable.rad_restore)

			eatable.stamina_restore = (get_booster_stat_value(nil, section, "boost_power_restore") or 0) / 100
			eatable.total_stamina_restore = to_percent_floor(eatable.duration * eatable.stamina_restore)
			eatable.stamina_restore = to_percent_string(eatable.stamina_restore)

			eatable.radiation_prot = math.floor(get_booster_stat_value(nil, section, "boost_radiation_protection") or 0)
			eatable.chemical_prot = to_percent_floor(get_booster_stat_value(nil, section, "boost_chemburn_protection"))
			eatable.psychic_prot = math.floor(get_booster_stat_value(nil, section, "boost_telepat_protection") or 0)
			eatable.weight_carried = ini_sys:r_float_ex(section, "boost_max_weight") or 0

			tbl[section] = eatable
			cnt = cnt + 1
        end
    end)

	local p_file = "export_eatable.csv"
	local debug_file = io.open(p_file,"w+")
	--csv header
	--write_file(debug_file, "~ ,      Name,   Weight kg, Base Cost, Tier, Sleepiness,   Thirstiness,   Alcohol,   Health Change, Rads mSv/s, Satiety Level, Servings,   Used in Cooking?,  From Cooking?,  Duration,  Health Res.,       Total Health Res.,      Bleed Res. ml min, Total Bleed Res.,       Rad Res. msv sec, Total Rad Res.,       Stamina Res. mg,   Total Stamina Res.,      Radiation Prot. msv, Chemical Prot. %, Psychic Prot. mt, Weight Carried kg")
	for section,v in pairs(tbl) do
		write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
	  --~ ,      Name,   Weight kg, Base Cost, Tier, Sleepiness,   Thirstiness,   Alcohol,   Health Change, Rads mSv/s, Satiety Level, Servings,   Used in Cooking?,  From Cooking?,  Duration,  Health Res.,       Total Health Res.,      Bleed Res. ml min, Total Bleed Res.,       Rad Res. msv sec, Total Rad Res.,       Stamina Res. mg,   Total Stamina Res.,      Radiation Prot. msv, Chemical Prot. %, Psychic Prot. mt, Weight Carried kg
		section, v.name, v.weight,  v.cost,  v.tier, v.sleepiness, v.thirstiness, v.alcohol, v.health,      v.rads,     v.satiety,     v.servings, v.used_in_cooking, v.from_cooking, v.duration, v.health_restore, v.total_health_restore, v.bleed_restore,   v.total_bleed_restore,  v.rad_restore,    v.total_rad_restore,  v.stamina_restore, v.total_stamina_restore, v.radiation_prot,    v.chemical_prot,  v.psychic_prot,   v.weight_carried)
	end
	debug_file:close()

	x:SendOutput("[END] export outfit - %s total eatable exported - see in Gamma\\Overwrite\\bin\\export_eatable.csv", cnt)
end

function build_bhs_summary(t_name, sec)
	local head = 0
	local torso = 0
	local arm = 0
	local leg = 0
	local timeregen = 0
	if sec and t_name[sec] then
		for limb, val in pairs(t_name[sec]) do
			if limb == "head" then
				head = val
			elseif limb == "torso" then
				torso = val
			elseif limb == "rightarm" then
				arm = val
			elseif limb == "rightleg" then
				leg = val
			elseif limb == "timeregen" then
				timeregen = val / 1000
			end
		end
	end
	return head, torso, arm, leg, timeregen
end

--See ui_workshop.script::UIWorkshopCraft:LoadRecipes
function export_recipes(craft_index)
	local used_in_crafting = {}
	local craftable = {}

	local ini = itms_manager.ini_craft
	local ind_str = tostring(craft_index)
	local n = ini:line_count(ind_str) or 0
	for i=0, n-1 do
		local result, id, value = ini:r_line(ind_str , i , "", "")
		id = string.sub(id,3)
		if ini_sys:section_exist(id) then
			if not craftable[id] then
				craftable[id] = {}
			end
			local t = str_explode(value,",")
			if (#t == 6) or (#t == 8) or (#t == 10) then
				local x = #craftable[id] + 1
				craftable[id][x] = {}
				if t[3] and t[4] then -- support item 1
					if ini_sys:section_exist(tostring(t[3])) then
						local amt = tonumber(t[4])
						craftable[id][x][1] = {tostring(t[3]), amt}
						used_in_crafting[tostring(t[3])] = true
					end
				end
				if t[5] and t[6] then -- support item 2
					if ini_sys:section_exist(tostring(t[5])) then
						local amt = tonumber(t[6])
						craftable[id][x][2] = {tostring(t[5]), amt}
						used_in_crafting[tostring(t[5])] = true
					end
				end
				if t[7] and t[8] then -- support item 3
					if ini_sys:section_exist(tostring(t[7])) then
						local amt = tonumber(t[8])
						craftable[id][x][3] = {tostring(t[7]), amt}
						used_in_crafting[tostring(t[7])] = true
					end
				end
				if t[9] and t[10] then -- support item 4
					if ini_sys:section_exist(tostring(t[9])) then
						local amt = tonumber(t[10])
						craftable[id][x][4] = {tostring(t[9]), amt}
						used_in_crafting[tostring(t[9])] = true
					end
				end
			end
		end
	end

	return used_in_crafting, craftable
end

function export_medicine_recipes()
	return export_recipes(5)
end

function export_artefacts_recipes()
	return export_recipes(7)
end

function cmd.export_medicine(_, txt, x)
	x:SendOutput("[START] export medicine")

	local food_kinds = {
		["i_medical"] = true,
		["II_BANDG"] = true,
		["II_MEDKI"] = true,
		["II_ANTIR"] = true,
	}

	local blacklist = {
		["medkit_script"] = true,
		["mp_medkit_scientic"] = true,
		["mp_medkit_army"] = true,
		["mp_medkit"] = true,
		["mp_drug_radioprotector"] = true,
		["mp_drug_coagulant"] = true,
		["mp_bandage"] = true,
		["mp_antirad"] = true,
		["medkit_ai1"] = true,
		["medkit_ai2"] = true,
		["medkit_ai3"] = true,
	}

	local used_in_crafting, craftable = export_medicine_recipes()

	local tbl = {}
	local cnt = 0
	ini_sys:section_for_each(function(section)
		if blacklist[section] or is_multiplayer_item(section) then
			return
		end
		local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing

		if kind and food_kinds[kind] then
			x:SendOutput("export medicine - %s", section)
			local eatable = {}
			eatable.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name")) or ""
			eatable.cost = ini_sys:r_float_ex(section, "cost") or 0
			eatable.weight = ini_sys:r_float_ex(section, "inv_weight") or 0
			eatable.tier = ini_sys:r_float_ex(section, "tier") or 0
			eatable.sleepiness = to_percent_round(getEatableSleepiness(section))
			eatable.thirstiness = to_percent_floor(getEatableThirstiness(section))
			eatable.alcohol = to_percent_floor(getEatableAlcohol(section))
			eatable.health = to_percent_string((ini_sys:r_float_ex(section, "eat_health") or 0) * 100)
			eatable.satiety = to_percent_floor(getEatableSatiety(section))
			eatable.servings = ini_sys:r_float_ex(section, "max_uses") or 1

			eatable.duration = get_booster_stat_value(nil, section, "boost_time") or 0

			eatable.health_restore = get_booster_stat_value(nil, section, "boost_health_restore") or 0
			eatable.total_health_restore = to_percent_floor(eatable.duration * eatable.health_restore)
			eatable.health_restore = to_percent_string(eatable.health_restore)

			eatable.bleed_restore = (get_booster_stat_value(nil, section, "boost_bleeding_restore") or 0)/1000
			eatable.total_bleed_restore = eatable.duration * eatable.bleed_restore

			eatable.rad_restore = math.floor(get_booster_stat_value(nil, section, "boost_radiation_restore") or 0)
			eatable.total_rad_restore = math.floor(eatable.duration * eatable.rad_restore)

			eatable.stamina_restore = (get_booster_stat_value(nil, section, "boost_power_restore") or 0) / 100
			eatable.total_stamina_restore = to_percent_floor(eatable.duration * eatable.stamina_restore)
			eatable.stamina_restore = to_percent_string(eatable.stamina_restore)

			eatable.radiation_prot = to_percent_floor(get_booster_stat_value(nil, section, "boost_radiation_protection") or 0)
			eatable.chemical_prot = to_percent_floor(get_booster_stat_value(nil, section, "boost_chemburn_protection"))
			eatable.psychic_prot = to_percent_floor(get_booster_stat_value(nil, section, "boost_telepat_protection") or 0)

			eatable.burn_immunity = to_percent_string(get_booster_stat_value(nil, section, "boost_burn_immunity") or 0)
			eatable.shock_immunity = to_percent_string(get_booster_stat_value(nil, section, "boost_shock_immunity") or 0)
			eatable.radiation_immunity = to_percent_string(get_booster_stat_value(nil, section, "boost_radiation_immunity") or 0)
			eatable.psychic_immunity = to_percent_string(get_booster_stat_value(nil, section, "boost_telepat_immunity") or 0)
			eatable.chemical_burn_immunity = to_percent_string(get_booster_stat_value(nil, section, "boost_chemburn_immunity") or 0)

			eatable.impact_immunity = to_percent_string((ini_sys:r_float_ex(section, "boost_strike_immunity") or 0) * 100)
			eatable.rupture_immunity = to_percent_string((ini_sys:r_float_ex(section, "boost_wound_immunity") or 0) * 100)
			eatable.explosion_immunity = to_percent_string((ini_sys:r_float_ex(section, "boost_explosion_immunity") or 0) * 100)
			eatable.ballistic_immunity = to_percent_string((ini_sys:r_float_ex(section, "boost_fire_wound_immunity") or 0) * 100)

			eatable.weight_carried = ini_sys:r_float_ex(section, "boost_max_weight") or 0

			eatable.perm_head, eatable.perm_torso, eatable.perm_arm, eatable.perm_leg, eatable.perm_timeregen = build_bhs_summary(zzz_player_injuries.healhelp, section)
			eatable.temp_head, eatable.temp_torso, eatable.temp_arm, eatable.temp_leg, eatable.hp_active = build_bhs_summary(zzz_player_injuries.medkits, section)

			eatable.used_in_crafting = used_in_crafting[section] and "Y" or "N"
			eatable.craftable = craftable[section] and "Y" or "N"

			tbl[section] = eatable
			cnt = cnt + 1
		end
	end)

	local p_file = "export_medicine.csv"
	local debug_file = io.open(p_file,"w+")
	--csv header
	--write_file(debug_file, "~ ,      Name,   Weight kg, Base Cost, Tier, Sleepiness,   Thirstiness,   Alcohol,   Health Change, Health Regen,   Perm Head,   Perm Torso,   Perm Arm,   Perm Leg,   Temp Head,   Temp Torso,   Temp Arm,   Temp Leg,   Burn Immunity,   Shock Immunity,   Radiation Immunity,   Psychic Immunity,   Chemical Burn Immunity,   Impact Immunity,   Rupture Immunity,   Explosion Immunity,   Ballistic Immunity,   Satiety Level, Servings,   Duration,   Health Res.,      Total Health Res.,      Bleed Res. ml min, Total Bleed Res.,      Rad Res. msv sec, Total Rad Res.,      Stamina Res. mg,   Total Stamina Res.,      Radiation Prot. msv, Chemical Prot.,  Psychic Prot. mt, Weight Carried kg, Used In Crafting,   Craftable")
	for section,v in pairs(tbl) do
		write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
	  --~ ,      Name,   Weight kg, Base Cost, Tier, Sleepiness,   Thirstiness,   Alcohol,   Health Change, HP Active,   Perm Head,   Perm Torso,   Perm Arm,   Perm Leg,   Temp Head,   Temp Torso,   Temp Arm,   Temp Leg,   Burn Immunity,   Shock Immunity,   Radiation Immunity,   Psychic Immunity,   Chemical Burn Immunity,   Impact Immunity,   Rupture Immunity,   Explosion Immunity,   Ballistic Immunity,   Satiety Level, Servings,   Duration,   Health Res.,      Total Health Res.,      Bleed Res. ml min, Total Bleed Res.,      Rad Res. msv sec, Total Rad Res.,      Stamina Res. mg,   Total Stamina Res.,      Radiation Prot. msv, Chemical Prot.,  Psychic Prot. mt, Weight Carried kg, Used In Crafting,   Craftable
		section, v.name, v.weight,  v.cost,  v.tier, v.sleepiness, v.thirstiness, v.alcohol, v.health,      v.hp_active, v.perm_head, v.perm_torso, v.perm_arm, v.perm_leg, v.temp_head, v.temp_torso, v.temp_arm, v.temp_leg, v.burn_immunity, v.shock_immunity, v.radiation_immunity, v.psychic_immunity, v.chemical_burn_immunity, v.impact_immunity, v.rupture_immunity, v.explosion_immunity, v.ballistic_immunity, v.satiety,     v.servings, v.duration, v.health_restore, v.total_health_restore, v.bleed_restore,   v.total_bleed_restore, v.rad_restore,    v.total_rad_restore, v.stamina_restore, v.total_stamina_restore, v.radiation_prot,    v.chemical_prot, v.psychic_prot,   v.weight_carried,  v.used_in_crafting, v.craftable)
	end
	debug_file:close()

	x:SendOutput("[END] export medicine - %s total medicine exported - see in Gamma\\Overwrite\\bin\\export_medicine.csv", cnt)
end

function get_perk_artifacts_list()
	local perk_artefacts = {}

	for i, v in pairs(perk_based_artefacts) do
		if type(v) == "table" and string.find(i, "artefact_on_") then
			for j, k in pairs(v) do
				perk_artefacts[j] = true
			end
		end
	end

	return perk_artefacts
end

function cmd.export_artefacts(_, txt, x)
	x:SendOutput("[START] export artefacts")

	local artefacts_kinds = {
		["i_arty"] = true,
		["i_arty_junk"] = true,
		["ARTEFACT"] = true,
		["SCRPTART"] = true,
	}

	local blacklist = {
		["mp_af_electra_flash"] = true,
		["monolith_shard"] = true,
		["jup_b1_half_artifact"] = true,
		["af_rusty_kristall"] = true,
		["af_rusty_sea"] = true,
		["af_rusty_thorn"] = true,
		["marker"] = true,
		["af_dummy_pellicle"] = true,
		["af_dummy_spring"] = true,
		["af_ameba_slug"] = true,
		["af_ameba_mica"] = true,
		["af_ameba_slime"] = true,
		["af_drops"] = true,
	}

	local used_in_crafting, craftable = export_artefacts_recipes()
	local perk_artefacts = get_perk_artifacts_list()

	local tbl = {}
	local cnt = 0
	ini_sys:section_for_each(function(section)
		if blacklist[section] or is_multiplayer_item(section) then
			return
		end
		local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing

		if kind and artefacts_kinds[kind] then
			x:SendOutput("export artefact - %s", section)
			local artefact = {}
			artefact.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name")) or ""
			artefact.cost = ini_sys:r_float_ex(section, "cost") or 0
			artefact.weight = ini_sys:r_float_ex(section, "inv_weight") or 0
			artefact.tier = ini_sys:r_float_ex(section, "tier") or 0
			artefact.rank = ini_sys:r_float_ex(section, "af_rank") or 0
			artefact.is_junk = kind == "i_arty_junk" and "Y" or "N"
			artefact.has_perk = perk_artefacts[section] and "Y" or "N"
			artefact.jump_height = ini_sys:r_float_ex(section, "jump_height") or 0

			artefact.health_restore = get_artefact_stat_value(nil, section, "health_restore_speed")
			artefact.rad_restore = math.floor(get_artefact_stat_value(nil, section, "radiation_restore_speed") or 0)
			artefact.bleed_restore = (get_artefact_stat_value(nil, section, "bleeding_restore_speed") or 0)/1000
			artefact.stamina_restore = to_percent_round((get_artefact_stat_value(nil, section, "power_restore_speed") or 0))
			artefact.satiety_restore = to_percent_string(getSatietyPercent(get_artefact_stat_value(nil, section, "satiety_restore_speed")))

			artefact.burn_immunity = to_percent_string(get_artefact_stat_value(nil, section, "burn_immunity") or 0)
			artefact.shock_immunity = to_percent_string(get_artefact_stat_value(nil, section, "shock_immunity") or 0)
			artefact.radiation_immunity = to_percent_string(get_artefact_stat_value(nil, section, "radiation_immunity") or 0)
			artefact.psychic_immunity = to_percent_string(get_artefact_stat_value(nil, section, "telepatic_immunity") or 0)
			artefact.chemical_burn_immunity = to_percent_string(get_artefact_stat_value(nil, section, "chemical_burn_immunity") or 0)

			artefact.rupture_immunity = to_percent_string(get_artefact_stat_value(nil, section, "wound_immunity") or 0)
			artefact.ballistic_immunity = to_percent_string(get_artefact_stat_value(nil, section, "fire_wound_immunity") or 0)
			artefact.explosion_immunity = to_percent_string(get_artefact_stat_value(nil, section, "explosion_immunity") or 0)
			artefact.impact_immunity = to_percent_string(get_artefact_stat_value(nil, section, "strike_immunity") or 0)

			artefact.weight_carried = get_artefact_stat_value(nil, section, "additional_inventory_weight") or 0

			artefact.burn_cap = to_percent_string(get_artefact_stat_value(nil, section, "burn_cap") or 0)
			artefact.shock_cap = to_percent_string(get_artefact_stat_value(nil, section, "shock_cap") or 0)
			artefact.telepatic_cap = to_percent_string(get_artefact_stat_value(nil, section, "telepatic_cap") or 0)
			artefact.chemical_burn_cap = to_percent_string(get_artefact_stat_value(nil, section, "chemical_burn_cap") or 0)

			artefact.rupture_cap = to_percent_string(get_artefact_stat_value(nil, section, "wound_cap") or 0)
			artefact.ballistic_cap = to_percent_string(get_artefact_stat_value(nil, section, "fire_wound_cap") or 0)
			artefact.explosion_cap = to_percent_string(get_artefact_stat_value(nil, section, "explosion_cap") or 0)
			artefact.impact_cap = to_percent_string(get_artefact_stat_value(nil, section, "strike_cap") or 0)

			artefact.used_in_crafting = used_in_crafting[section] and "Y" or "N"
			artefact.craftable = craftable[section] and "Y" or "N"

			tbl[section] = artefact
			cnt = cnt + 1
		end
	end)


	local function write_file(file, text,...)
		if not text then return end

		local i = 0
		local p = {...}
		local function sr(a)
			i = i + 1
			return tostring(p[i])
		end
		local output = string.gsub(text,"%%s",sr)
		file:write(output.."\n")
	end

	local p_file = "export_artefacts.csv"
	local debug_file = io.open(p_file,"w+")
	--csv header
	--write_file(debug_file, "~ ,      Name,   Weight kg, Base Cost, Tier,   Rank,   Jump Height,   Is Junk,   Has Perk,   Burn Immunity,   Shock Immunity,   Radiation Immunity,   Psychic Immunity,   Chemical Burn Immunity,   Impact Immunity,   Rupture Immunity,   Explosion Immunity,   Ballistic Immunity,   Health Res.,      Satiety Res.,      Bleed Res. ml min, Rad Res. msv sec, Stamina Res. mg,   Burn Cap,   Shock Cap,   Telepatic Cap,   Chemical Burn Cap,   Rupture Cap,   Ballistic Cap,   Explosion Cap,   Impact Cap,   Weight Carried kg, Used In Crafting,   Craftable")
	for section,v in pairs(tbl) do
		write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
	  --~ ,      Name,   Weight kg, Base Cost, Tier,   Rank,   Jump Height,   Is Junk,   Has Perk,   Burn Immunity,   Shock Immunity,   Radiation Immunity,   Psychic Immunity,   Chemical Burn Immunity,   Impact Immunity,   Rupture Immunity,   Explosion Immunity,   Ballistic Immunity,   Health Res.,      Satiety Res.,      Bleed Res. ml min, Rad Res. msv sec, Stamina Res. mg,   Burn Cap,   Shock Cap,   Telepatic Cap,   Chemical Burn Cap,   Rupture Cap,   Ballistic Cap,   Explosion Cap,   Impact Cap,   Weight Carried kg, Used In Crafting,   Craftable
		section, v.name, v.weight,  v.cost,    v.tier, v.rank, v.jump_height, v.is_junk, v.has_perk, v.burn_immunity, v.shock_immunity, v.radiation_immunity, v.psychic_immunity, v.chemical_burn_immunity, v.impact_immunity, v.rupture_immunity, v.explosion_immunity, v.ballistic_immunity, v.health_restore, v.satiety_restore, v.bleed_restore,   v.rad_restore,    v.stamina_restore, v.burn_cap, v.shock_cap, v.telepatic_cap, v.chemical_burn_cap, v.rupture_cap, v.ballistic_cap, v.explosion_cap, v.impact_cap, v.weight_carried,  v.used_in_crafting, v.craftable
		)
	end
	debug_file:close()

	x:SendOutput("[END] export artefacts - %s total artefacts exported - see in Gamma\\Overwrite\\bin\\export_artefacts.csv", cnt)
end

function cmd.export_artefact_recipes(_, txt, x)
	x:SendOutput("[START] export artefact recipes")

	local used_in_crafting, craftable = export_artefacts_recipes()

	local tbl = {}
	local cnt = 0
	for section, recipes in pairs(craftable) do
		for i, raw_recipe in ipairs(recipes) do
			local recipe = {}
			recipe.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name")) or ""
			recipe.ingr_1_name = raw_recipe[1] and ini_sys:r_string_ex(raw_recipe[1][1], "inv_name") and game.translate_string(ini_sys:r_string_ex(raw_recipe[1][1], "inv_name")) or ""
			recipe.ingr_1_amt = raw_recipe[1] and raw_recipe[1][2] and "x" .. raw_recipe[1][2] or ""
			recipe.ingr_2_name = raw_recipe[2] and ini_sys:r_string_ex(raw_recipe[2][1], "inv_name") and game.translate_string(ini_sys:r_string_ex(raw_recipe[2][1], "inv_name")) or ""
			recipe.ingr_2_amt = raw_recipe[2] and raw_recipe[2][2] and "x" .. raw_recipe[2][2] or ""
			recipe.ingr_3_name = raw_recipe[3] and ini_sys:r_string_ex(raw_recipe[3][1], "inv_name") and game.translate_string(ini_sys:r_string_ex(raw_recipe[3][1], "inv_name")) or ""
			recipe.ingr_3_amt = raw_recipe[3] and raw_recipe[3][2] and "x" .. raw_recipe[3][2] or ""
			recipe.ingr_4_name = raw_recipe[4] and ini_sys:r_string_ex(raw_recipe[4][1], "inv_name") and game.translate_string(ini_sys:r_string_ex(raw_recipe[4][1], "inv_name")) or ""
			recipe.ingr_4_amt = raw_recipe[4] and raw_recipe[4][2] and "x" .. raw_recipe[4][2] or ""
			tbl[section] = recipe
			cnt = cnt + 1
		end
	end

	local p_file = "export_artefact_recipes.csv"
	local debug_file = io.open(p_file,"w+")
	--csv header
	--write_file(debug_file, "~ ,      Name,   Weight kg, Base Cost, Tier,   Rank,   Is Junk,   Has Perk,   Burn Immunity,   Shock Immunity,   Radiation Immunity,   Psychic Immunity,   Chemical Burn Immunity,   Impact Immunity,   Rupture Immunity,   Explosion Immunity,   Ballistic Immunity,   Health Res.,      Satiety Res.,      Bleed Res. ml min, Rad Res. msv sec, Stamina Res. mg,   Burn Cap,   Shock Cap,   Telepatic Cap,   Chemical Burn Cap,   Rupture Cap,   Ballistic Cap,   Explosion Cap,   Impact Cap,   Weight Carried kg, Used In Crafting,   Craftable")
	for section,v in pairs(tbl) do
		write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
	  --~ ,      Name,   Ingr 1 Name,   Ingr 1 Amt,   Ingr 2 Name,   Ingr 2 Amt,   Ingr 3 Name,   Ingr 3 Amt,   Ingr 4 Name,   Ingr 4 Amt
		section, v.name, v.ingr_1_name, v.ingr_1_amt, v.ingr_2_name, v.ingr_2_amt, v.ingr_3_name, v.ingr_3_amt, v.ingr_4_name, v.ingr_4_amt
		)
	end
	debug_file:close()

	x:SendOutput("[END] export artefact recipes - %s total recipes exported - see in Gamma\\Overwrite\\bin\\export_artefact_recipes.csv", cnt)
end

function cmd.export_belt_attachments(_, txt, x)
	x:SendOutput("[START] export belt attachments")

	local artefacts_kinds = {
		["i_mutant_belt"] = true,
		["i_attach"] = true,
		["i_backpack"] = true,
		["EQ_BAKPK"] = true,
	}

	local blacklist = {
		["fieldcraft_plate_attch"] = true,
		["test_container"] = true,
	}

	local used_in_crafting, craftable = export_artefacts_recipes()

	local tbl = {}
	local cnt = 0
	ini_sys:section_for_each(function(section)
		if blacklist[section] or is_multiplayer_item(section) then
			return
		end
		local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing

		if kind and artefacts_kinds[kind] then
			x:SendOutput("export belt attachment - %s", section)
			local belt_attachment = {}
			belt_attachment.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name")) or ""
			belt_attachment.cost = ini_sys:r_float_ex(section, "cost") or 0
			belt_attachment.weight = ini_sys:r_float_ex(section, "inv_weight") or 0
			belt_attachment.tier = ini_sys:r_float_ex(section, "tier") or 0
			belt_attachment.jump_height = ini_sys:r_float_ex(section, "jump_height") or 0
			belt_attachment.bonus_mutant_part_chance = to_percent_string(ini_sys:r_float_ex(section, "bonus_mutant_part_chance"))

			belt_attachment.health_restore = get_artefact_stat_value(nil, section, "health_restore_speed")
			belt_attachment.rad_restore = math.floor(get_artefact_stat_value(nil, section, "radiation_restore_speed") or 0)
			belt_attachment.bleed_restore = (get_artefact_stat_value(nil, section, "bleeding_restore_speed") or 0)/1000
			belt_attachment.stamina_restore = to_percent_round(get_artefact_stat_value(nil, section, "power_restore_speed"))
			belt_attachment.satiety_restore = to_percent_string(getSatietyPercent(get_artefact_stat_value(nil, section, "satiety_restore_speed")))

			belt_attachment.burn_immunity = to_percent_string(get_artefact_stat_value(nil, section, "burn_immunity") or 0)
			belt_attachment.shock_immunity = to_percent_string(get_artefact_stat_value(nil, section, "shock_immunity") or 0)
			belt_attachment.radiation_immunity = to_percent_string(get_artefact_stat_value(nil, section, "radiation_immunity") or 0)
			belt_attachment.psychic_immunity = to_percent_string(get_artefact_stat_value(nil, section, "telepatic_immunity") or 0)
			belt_attachment.chemical_burn_immunity = to_percent_string(get_artefact_stat_value(nil, section, "chemical_burn_immunity") or 0)

			belt_attachment.rupture_immunity = to_percent_string(get_artefact_stat_value(nil, section, "wound_immunity") or 0)
			belt_attachment.ballistic_immunity = to_percent_string(get_artefact_stat_value(nil, section, "fire_wound_immunity") or 0)
			belt_attachment.explosion_immunity = to_percent_string(get_artefact_stat_value(nil, section, "explosion_immunity") or 0)
			belt_attachment.impact_immunity = to_percent_string(get_artefact_stat_value(nil, section, "strike_immunity") or 0)

			belt_attachment.weight_carried = get_artefact_stat_value(nil, section, "additional_inventory_weight") or 0

			tbl[section] = belt_attachment
			cnt = cnt + 1
		end
	end)


	local function write_file(file, text,...)
		if not text then return end

		local i = 0
		local p = {...}
		local function sr(a)
			i = i + 1
			return tostring(p[i])
		end
		local output = string.gsub(text,"%%s",sr)
		file:write(output.."\n")
	end

	local p_file = "export_belt_attachments.csv"
	local debug_file = io.open(p_file,"w+")
	--csv header
	--write_file(debug_file, "~ ,      Name,   Weight kg, Base Cost, Tier,   Jump Height,   Bonus Mutant Part Chance,   Burn Immunity,   Shock Immunity,   Radiation Immunity,   Psychic Immunity,   Chemical Burn Immunity,   Impact Immunity,   Rupture Immunity,   Explosion Immunity,   Ballistic Immunity,   Health Res.,      Satiety Res.,      Bleed Res. ml min, Rad Res. msv sec, Stamina Res. mg,   Weight Carried kg")
	for section,v in pairs(tbl) do
		write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
		--~ ,      Name,   Weight kg, Base Cost, Tier,   Jump Height,   Bonus Mutant Part Chance,   Burn Immunity,   Shock Immunity,   Radiation Immunity,   Psychic Immunity,   Chemical Burn Immunity,   Impact Immunity,   Rupture Immunity,   Explosion Immunity,   Ballistic Immunity,   Health Res.,      Satiety Res.,      Bleed Res. ml min, Rad Res. msv sec, Stamina Res. mg,   Weight Carried kg
				section, v.name, v.weight,  v.cost,    v.tier, v.jump_height, v.bonus_mutant_part_chance, v.burn_immunity, v.shock_immunity, v.radiation_immunity, v.psychic_immunity, v.chemical_burn_immunity, v.impact_immunity, v.rupture_immunity, v.explosion_immunity, v.ballistic_immunity, v.health_restore, v.satiety_restore, v.bleed_restore,   v.rad_restore,    v.stamina_restore, v.weight_carried
		)
	end
	debug_file:close()

	x:SendOutput("[END] export belt attachments - %s total attachments exported - see in Gamma\\Overwrite\\bin\\export_belt_attachments.csv", cnt)
end

local ammo_special_types = {
	["gauss"] = "Gauss Batteries",
	["pkm_100"] = "7.62x54  PP",
	["magnum_300"] = ".338 Lapua Magnum",
	["m209"] = "M203",
	["357_hp"] = ".357 HP",
	["25"] = "VOG-25", --for some reason vog-25 doesn't work
	["30"] = "VOG-30", --for some reason vog-30 doesn't work
	["7b"] = "OG-7V", --for some reason og-7b doesn't work
	["23_eco"] = "Ecolog-23",
	["338"] = ".338 Federal",
}

function get_weapon_caliber(ammo_class)
	--printf("ammo_class: %s", ammo_class)
	local ammo_tbl = str_explode(ammo_class,",")
	if #ammo_tbl == 0 then
		return ""
	end
	local ammo_types = {}

	for i, ammo in ipairs(ammo_tbl) do
		--printf("ammo: %s", ammo)
		local regular_start, regular_end = string.find(ammo, "[0-9.]*x[0-9]*")
		if regular_start then
			ammo_types[string.sub(ammo, regular_start, regular_end)] = true
		else
			for ammo_type, label in pairs(ammo_special_types) do
				local special_start, special_end = string.find(ammo, ammo_type)
				--printf("try: %s - %s", ammo_type, special_start)
				if special_start then
					ammo_types[label] = true
				end
			end
		end
	end

	local ammo_list = ""

	for ammo_type, _ in pairs(ammo_types) do
		if ammo_list == "" then
			ammo_list = ammo_type
		else
			ammo_list = ammo_list .. "; " .. ammo_type
		end
	end

	return ammo_list
end

function armor_to_class(val)
	if (val < 11) then val = 0
	elseif ( (val >= 11) and (val < 19) ) then val = 1
	elseif ( (val >= 19) and (val < 30) ) then val = 2
	elseif ( (val >= 30) and (val < 39) ) then val = 3
	elseif ( (val >= 39) and (val < 46) ) then val = 4
	elseif ( (val >= 46) and (val < 55) ) then val = 5
	else val = 6
	end

	return val
end

function get_weapon_br_stats(ammo_class)
	local brs = {
		"", "", "", "", "", "", ""
	}
	local ammo_tbl = str_explode(ammo_class,",")
	--printf("ammo_class: %s", ammo_class)
	for i, ammo in ipairs(ammo_tbl) do
		local ap = ini_sys:r_float_ex(ammo, "k_ap") or 0
		--printf("%s %s", ammo, ap)
		ap = ap * 10 * 100 * get_game_difficulty_multiplier()
		local br = armor_to_class(ap)
		--printf("%s, %s", br, brs[br + 1])
		if br > 0 and (not brs[br + 1] or brs[br + 1] == "" or brs[br + 1] < ap) then
			brs[br + 1] = ap
		end
	end
	--printf(brs[7])
	return brs[1], brs[2], brs[3], brs[4], brs[5], brs[6], brs[7]
end

function get_weapon_repair_label(repair_type)
	if repair_type == "pistol" then
		return "A"
	elseif repair_type == "shotgun" then
		return "B"
	elseif repair_type == "rifle_5" then
		return "C"
	elseif repair_type == "rifle_7" then
		return "D"
	end
	return "N/A"
end

function cmd.export_weapons(_, txt, x)
	x:SendOutput("[START] export weapons")

	local weapon_kinds = {
		["w_pistol"]    = "pistol",
		["w_shotgun"]   = "shotgun",
		["w_smg"]       = "smg",
		["w_rifle"]     = "rifle",
		["w_sniper"]    = "sniper",
		["w_explosive"] = "explosive"
	}

	local blacklist = {
		["wpn_colt_kimber"] = true,
		["wpn_cz75_auto"] = true,
		["wpn_cz52"] = true,
	}

	local tbl = {}
	local cnt = 0
	local counter = 0
	ini_sys:section_for_each(function(section)
		if blacklist[section] or is_multiplayer_item(section) then
			return
		end

		local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing

		if kind and weapon_kinds[kind] then
			local weapon_class = ini_sys:r_string_ex(section, "weapon_class")
			if kind == "w_explosive" and (not weapon_class or weapon_class == "") then
				return
			end

			local parent_section = ini_sys:r_string_ex(section, "parent_section")
			if parent_section and section ~= parent_section then
				return
			end

			kind = weapon_kinds[kind]
			if not tbl[kind] then
				tbl[kind] = {}
			end

			local pos = db.actor:position()
			local lvid = db.actor:level_vertex_id()
			local gvid = db.actor:game_vertex_id()
			local id = AC_ID

			local se_obj
			se_obj = alife_create_item(section, {pos, lvid, gvid, id} )

			if not se_obj then
				--printf( "No server object made for [%s]", section)
				--x:SendOutput( "No server object made for [%s]", section)
				return
			end
			cnt = cnt + 1
			counter = counter + 1
			local id = se_obj.id

			x:SendOutput("export weapon - %s, start", section)
			local function createInterval(section, id, callback, idx)
				CreateTimeEvent("export_weapon_"..section.."_"..idx, "delay_func", 2, function(section, id)
					local success = callback(section, id)
					if not success then
						createInterval(section, id, callback, idx + 1)
					end
					return true
				end, section, id)
			end

			createInterval(section, id, function(section, id)
				local obj = level.object_by_id(id)
				if not obj then
					--x:SendOutput("export weapon - %s, still online", section)
					return false
				end

				--x:SendOutput("export weapon - %s, back offline", section)
				local weapon = {}
				weapon.type = kind
				weapon.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name")) or ""
				weapon.cost = ini_sys:r_float_ex(section, "cost") or 0
				weapon.weight = ini_sys:r_float_ex(section, "inv_weight") or 0
				local repair_type = ini_sys:r_string_ex(section, "repair_type") or ""
				weapon.repair_label = get_weapon_repair_label(repair_type)
				weapon.single_handed = ini_sys:r_float_ex(section, "single_handed")
				weapon.single_handed = weapon.single_handed == 1 and "Y" or "N"

				weapon.accuracy = to_percent_floor(get_weapon_stat_value(obj, section, "accuracy"))
				weapon.handling = to_percent_floor(get_weapon_stat_value(obj, section, "handling"))
				weapon.damage = get_weapon_stat_value(obj, section, "damage")
				weapon.fire_rate = get_weapon_stat_value(obj, section, "fire_rate")
				weapon.ammo_mag_size = get_weapon_stat_value(obj, section, "ammo_mag_size")
				weapon.max_range = get_weapon_stat_value(obj, section, "max_range")
				weapon.speed = math.floor(get_weapon_stat_value(obj, section, "speed"))
				weapon.reliability = to_percent_floor(get_weapon_stat_value(obj, section, "reliability"))
				weapon.recoil = math.floor(get_weapon_stat_value(obj, section, "recoil"))

				local ammo_class = ini_sys:r_string_ex(section,"ammo_class") or ""
				weapon.caliber = get_weapon_caliber(ammo_class)

				local alt_calibers_cnt = 1
				local alt_calibers = {}
				local tree = utils_item.get_upgrades_tree(section)
				for row, v in pairs(tree) do
					for col, w in pairs(v) do
						local sec = w.section
						local upgrade_sec = ini_sys:r_string_ex(sec, "section")
						if upgrade_sec then
							local ammo_class = ini_sys:r_string_ex(upgrade_sec, "ammo_class")
							if ammo_class then
								alt_calibers[alt_calibers_cnt] = get_weapon_caliber(ammo_class)
								alt_calibers_cnt = alt_calibers_cnt + 1
							end
						end
					end
				end

				local alt_calibers_str = ""
				for i, v in ipairs(alt_calibers) do
					if alt_calibers_str == "" then
						alt_calibers_str = v
					else
						alt_calibers_str = alt_calibers_str .. "; " .. v
					end
				end

				weapon.alt_caliber = alt_calibers_str

				weapon.br1, weapon.br2, weapon.br3, weapon.br4, weapon.br5, weapon.br6 , weapon.br7 = get_weapon_br_stats(ammo_class)  --br1 is br0

				tbl[kind][section] = weapon
				alife_release(se_obj)
				x:SendOutput("export weapon - %s, done", section)
				counter = counter - 1
				return true
			end, 0)
		end
	end)

	local function createTotalInterval(callback, idx)
		CreateTimeEvent("export_weapons_total_" .. idx, "delay_func", 5, function()
			local success = callback()
			if not success then
				createTotalInterval(callback, idx + 1)
			end
			return true
		end)
	end

	createTotalInterval(function()
		if counter > 0 then
			x:SendOutput("export weapons - %s weapons still to do", counter)
			return false
		end

		for weapon_type, weapons in pairs(tbl) do
			local type_cnt = 0
			local p_file = "export_weapons_" .. weapon_type .. ".csv"
			local debug_file = io.open(p_file,"w+")

			if ( debug_file == nil ) then
				x:SendOutput("Failed to create/open file %s", p_file)
				debug_file:close()
				return true
			end

			--csv header
			--write_file(debug_file, "~,       Type,   Name,   Repair Label,   Single Handed,   Base Cost, Accuracy,   Handling,   Damage,   Fire Rate,   Ammo Mag Size,   Max Range,   Speed,   Reliability,   Recoil,   Weight kg, Caliber,   Alt Caliber,   BR0,   BR1,   BR2,   BR3,   BR4,   BR5,   BR6")
			for section, w in pairs(weapons) do
				write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
			  --~,       Type,   Name,   Repair Label,   Single Handed,   Base Cost, Accuracy,   Handling,   Damage,   Fire Rate,   Ammo Mag Size,   Max Range,   Speed,   Reliability,   Recoil,   Weight kg, Caliber,   Alt Caliber,   BR0,   BR1,   BR2,   BR3,   BR4,   BR5,   BR6
				section, w.type, w.name, w.repair_label, w.single_handed, w.cost,    w.accuracy, w.handling, w.damage, w.fire_rate, w.ammo_mag_size, w.max_range, w.speed, w.reliability, w.recoil, w.weight,  w.caliber, w.alt_caliber, w.br1, w.br2, w.br3, w.br4, w.br5, w.br6, w.br7)
				type_cnt = type_cnt + 1
			end
			debug_file:close()
			x:SendOutput("[END] export weapons - %s weapons exported - see %s", type_cnt, p_file)
		end

		x:SendOutput("[END] export weapons - %s total weapons exported - see in Gamma\\Overwrite\\bin", cnt)
		return true
	end, 0)
end

function get_heavy_attack_damage(obj, sec)
	local id = obj and obj:id()
	local hit_power = ini_sys:r_float_ex(sec, "hit_power_2") or 0
	local ammo_list = utils_item.get_ammo(sec, id)
	--printf("get_heavy_attack_damage - %s, hit_power %s, ammo_list %s", sec, hit_power, ammo_list[1])
	if ammo_list[1] then
		local k_hit = ini_sys:r_float_ex(ammo_list[1], "k_hit") or 1
		hit_power = (hit_power ~= 0) and (k_hit*hit_power) or k_hit
	end

	--printf("get_heavy_attack_damage - %s, hit_power %s", sec, hit_power)

	return normalize(hit_power, 0, 1.5)
end

function prop_damage(obj, sec, name)
	local hp_table = {}
	local values = {}
	local powers = {}
	local hit_power = 0

	if (not name) then
		return 0
	end

	hp_table = SYS_GetParam(0, obj and obj:section() or sec, name) or nil
	if hp_table ~= nil then
		values = str_explode(hp_table, ",")
		for i = 1, #values do
			powers[#powers + 1] = tonumber(values[i])
		end

		if powers ~= nil then
			hit_power = powers[game_difficulties.get_game_factor("actor_immunities") or 3] or 0
		end
	end

	return round_idp(hit_power * 100, 1)
end

function cmd.export_melee(_, txt, x)
	x:SendOutput("[START] export melee")

	local weapon_kinds = {
		["w_melee"]     = "melee",
		["WP_KNIFE"]    = "melee",
	}

	local blacklist = {
		["wpn_axe2"] = true,
	}

	local tbl = {}
	local cnt = 0
	local counter = 0
	ini_sys:section_for_each(function(section)
		if blacklist[section] or is_multiplayer_item(section) or string.find(section, "animation") then
			return
		end

		local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing

		if kind and weapon_kinds[kind] then
			kind = weapon_kinds[kind]
			if not tbl[kind] then
				tbl[kind] = {}
			end

			local pos = db.actor:position()
			local lvid = db.actor:level_vertex_id()
			local gvid = db.actor:game_vertex_id()
			local id = AC_ID

			local se_obj
			se_obj = alife_create_item(section, {pos, lvid, gvid, id} )

			if not se_obj then
				printf( "No server object made for [%s]", section)
				--x:SendOutput( "No server object made for [%s]", section)
				return
			end
			cnt = cnt + 1
			counter = counter + 1
			local id = se_obj.id

			x:SendOutput("export melee - %s, start", section)
			local function createInterval(section, id, callback, idx)
				CreateTimeEvent("export_melee_"..section.."_"..idx, "delay_func", 2, function(section, id)
					local success = callback(section, id)
					if not success then
						createInterval(section, id, callback, idx + 1)
					end
					return true
				end, section, id)
			end

			createInterval(section, id, function(section, id)
				local obj = level.object_by_id(id)
				if not obj then
					--x:SendOutput("export weapon - %s, still online", section)
					return false
				end

				--x:SendOutput("export weapon - %s, back offline", section)
				local weapon = {}
				weapon.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name")) or ""
				weapon.cost = ini_sys:r_float_ex(section, "cost") or 0
				weapon.weight = ini_sys:r_float_ex(section, "inv_weight") or 0
				weapon.max_range = get_weapon_stat_value(obj, section, "max_range")
				local ammo = ini_sys:r_string_ex(section, "ammo_class")
				weapon.br = (ammo and ini_sys:r_float_ex(ammo, "k_ap") or 0) * 10 * 100 * get_game_difficulty_multiplier()
				weapon.pelts_quality_min = zz_item_artefact.knifesm[section] and to_percent_string(zz_item_artefact.knifesm[section].min) or ""
				weapon.pelts_quality_max = zz_item_artefact.knifesm[section] and to_percent_string(zz_item_artefact.knifesm[section].max) or ""
				weapon.cuts_thick_skin = (section:match('wpn_knife$') or section:match('wpn_knife2$') or not string.find(section, "knife")) and "N" or "Y"
				weapon.light_attack_power = prop_damage(obj, section, "hit_power")
				weapon.heavy_attack_power = prop_damage(obj, section, "hit_power_2")

				tbl[kind][section] = weapon
				alife_release(se_obj)
				x:SendOutput("export melee - %s, done", section)
				counter = counter - 1
				return true
			end, 0)
		end
	end)

	local function createTotalInterval(callback, idx)
		CreateTimeEvent("export_melee_total_" .. idx, "delay_func", 5, function()
			local success = callback()
			if not success then
				createTotalInterval(callback, idx + 1)
			end
			return true
		end)
	end

	createTotalInterval(function()
		if counter > 0 then
			x:SendOutput("export melee - %s weapons still to do", counter)
			return false
		end

		for weapon_type, weapons in pairs(tbl) do
			local type_cnt = 0
			local p_file = "export_weapons_" .. weapon_type .. ".csv"
			local debug_file = io.open(p_file,"w+")

			if ( debug_file == nil ) then
				x:SendOutput("Failed to create/open file %s", p_file)
				debug_file:close()
				return true
			end

			--csv header
			--write_file(debug_file, "~,       Name,   Base Cost, Weight kg, Light Attack Power,   Heavy Attack Power,   BR,   Max Range,   Splash Hits,   Cuts Thick Skin,   Pelts Quality Min,   Pelts Quality Max")

			for section, w in pairs(weapons) do
				write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
			  --~,       Name,   Base Cost, Weight kg, Light Attack Power,   Heavy Attack Power,   BR,   Max Range,   Cuts Thick Skin,   Pelts Quality Min,   Pelts Quality Max
				section, w.name, w.cost,    w.weight,  w.light_attack_power, w.heavy_attack_power, w.br, w.max_range, w.cuts_thick_skin, w.pelts_quality_min, w.pelts_quality_max)
				type_cnt = type_cnt + 1
			end
			debug_file:close()
			x:SendOutput("[END] export melee - %s melee exported - see %s", type_cnt, p_file)
		end
		x:SendOutput("[END] export melee - %s total melee exported - see in Gamma\\Overwrite\\bin", cnt)
		return true
	end, 0)
end

function is_multiplayer_item(section)
	return not not string.find(section, "^mp_")
end

function cmd.export_explosives(_, txt, x)
	x:SendOutput("[START] export explosives")

	local mines = {}
	for mine, id in pairs(txr_mines.FX_BY_SECTION) do
		mines[id] = txr_mines.EXPLOSIVE_SECTION_LOOKUP[mine]
		--printf("mine %s, id %s", mine, id)
	end

	local blacklist = {
		[""] = true,
	}

	local tbl = {}
	local cnt = 0
	ini_sys:section_for_each(function(section)
		if blacklist[section] or is_multiplayer_item(section) then
			return
		end

		local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing
		local rocket_class = ini_sys:r_string_ex(section, "rocket_class")
		local fake_grenade_name = ini_sys:r_string_ex(section, "fake_grenade_name")
		local blast = ini_sys:r_float_ex(section, "blast")

		if rocket_class or fake_grenade_name or (kind and kind == "w_explosive" and blast) or mines[section] then
			local weapon_class = ini_sys:r_string_ex(section, "weapon_class")
			if weapon_class then
				--printf("export explosive - %s, weapon_class %s", section, weapon_class)
				return
			end
			local explosive = {}
			explosive.name = game.translate_string(ini_sys:r_string_ex(section, "inv_name"))
			if not explosive.name or explosive.name == "" then
				return
			end

			explosive.cost = ini_sys:r_float_ex(section, "cost") or 0
			if explosive.cost == 0 then
				return
			end
			x:SendOutput("export explosive - %s", section)
			explosive.weight = ini_sys:r_float_ex(section, "inv_weight") or 0
			local explosive_section = nil
			if rocket_class then
				explosive_section = rocket_class
			elseif fake_grenade_name then
				explosive_section = fake_grenade_name
			elseif mines[section] then
				explosive_section = mines[section]
			elseif kind and kind == "w_explosive" then
				explosive_section = section
			else
				x:SendOutput("export explosive - %s, no explosive section found", section)
				return
			end
			explosive.blast_power = ini_sys:r_float_ex(explosive_section, "blast") or 0
			explosive.blast_radius = ini_sys:r_float_ex(explosive_section, "blast_r") or 0
			explosive.frag_hit = ini_sys:r_float_ex(explosive_section, "frag_hit") or 0
			explosive.frags = ini_sys:r_float_ex(explosive_section, "frags") or 0
			explosive.delay = ini_sys:r_float_ex(explosive_section, "explode_duration") or 0

			tbl[section] = explosive
			cnt = cnt + 1
		end
	end)

	local p_file = "export_explosives.csv"
	local debug_file = io.open(p_file,"w+")
	--csv header
	--write_file(debug_file, "~ ,      Name,   Weight kg, Base Cost, Blast Power, Blast Radius, Frag Hit, Frags, Fragment Speed, Delay")
	for section, v in pairs(tbl) do
		write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s",
		  --~ ,      Name,   Weight kg, Base Cost, Blast Power,   Blast Radius,   Frags,   Frag Hit,   Delay
			section, v.name, v.weight,  v.cost,    v.blast_power, v.blast_radius, v.frags, v.frag_hit, v.delay
		)
	end
	debug_file:close()

	x:SendOutput("[END] export explosives - %s total explosives exported - see in Gamma\\Overwrite\\bin\\export_explosives.csv", cnt)
end

--local difficulty_scaling = ballistics_mcm and ballistics_mcm.get_config("difficulty_scaling") or false
local difficulty_scaling = false  --see cxv_ammo_stats_tbl.difficulty_multiplier for other values
local difficulty_multiplier = {
	[1]  = (difficulty_scaling and 1.3) or 1.0,
	[2]  = (difficulty_scaling and 1.05) or 1.0,
	[3]  = (difficulty_scaling and 0.90) or 1.0,
	[4]  = (difficulty_scaling and 0.80) or 1.0,
}
function get_game_difficulty_multiplier()
	local game_num = 1

	if difficulty_scaling then
		local gameplay = alife_storage_manager.get_state().diff_game
		if not (type(gameplay) == "table") then -- for old saves
			alife_storage_manager.get_state().diff_game = {}
			alife_storage_manager.get_state().diff_game["type"] = game_num
			gameplay = alife_storage_manager.get_state().diff_game
		end

		game_num = gameplay["type"] or game_num
		if game_num > 4 then game_num = 4 end 				-- in case someone is using a custom difficulty
	end

	return difficulty_multiplier[game_num]
end

function get_ammo_br_stat(ammo_section)
	local brs = {
		"", "", "", "", "", "", ""
	}
	local ap = ini_sys:r_float_ex(ammo_section, "k_ap") or 0
	ap = ap * 10 * 100 * get_game_difficulty_multiplier() --see cxv_ammo_stats_tbl.difficulty_multiplier for other values
	local br = armor_to_class(ap)
	brs[br + 1] = ap
	return brs[1], brs[2], brs[3], brs[4], brs[5], brs[6], brs[7]
end

function normalize_mutant_ammo_mod(mod)
	if not mod then
		return 0.01
	end

	return mod / 0.85
end

function sanitize_ammo_name(name)
	if not name or name == "" then
		return ""
	end

	local words_to_remove = {"mm", "rounds", "grenade", "round", "shells", "Grenade", "shells", "warhead"}
	for _, word in ipairs(words_to_remove) do
		name = string.gsub(name, "%f[%a]" .. word .. "%f[%A]", "")
	end
	return name

end

function cmd.export_ammo(_, txt, x)
	x:SendOutput("[START] export ammo")

	local blacklist = {
		["_knife"] = true,
		["_binoc"] = true,
		["_base$"] = true,
		["_dyno$"] = true,
		["_batteries"] = true,
		["^mp_"] = true,
		["_bad$"] = true,
		["_verybad$"] = true,
		["_heli$"] = true,
		["_parts$"] = true,
		["^casing_"] = true,
		["^powder_"] = true,
		["^bullet_"] = true,
	}

	local tbl = {}
	local cnt = 0
	ini_sys:section_for_each(function(section)
		for black, _ in pairs(blacklist) do
			if string.find(section, black) then
				return
			end
		end

		local kind = ini_sys:r_string_ex(section, "kind") -- special class name for the sake of correct listing

		if kind == "w_ammo" then
			x:SendOutput("export ammo - %s", section)
			local ammo = {}
			ammo.name = sanitize_ammo_name(game.translate_string(ini_sys:r_string_ex(section, "inv_name")))
			ammo.cost = ini_sys:r_float_ex(section, "cost") or 0
			ammo.weight = ini_sys:r_float_ex(section, "inv_weight") or 0
			ammo.projectiles = ini_sys:r_float_ex(section, "buck_shot") or 1
			ammo.damage = ini_sys:r_float_ex(section, "k_hit") or 0
			ammo.br1, ammo.br2, ammo.br3, ammo.br4, ammo.br5, ammo.br6, ammo.br7 = get_ammo_br_stat(section) --br1 is br0
			ammo.range = decimal_to_percent(ini_sys:r_float_ex(section, "k_dist"))
			ammo.velocity = decimal_to_percent(ini_sys:r_float_ex(section, "k_bullet_speed"))
			ammo.impulse = decimal_to_percent(ini_sys:r_float_ex(section, "k_impulse"))
			ammo.accuracy = decimal_to_percent(ini_sys:r_float_ex(section, "k_disp"))
			ammo.degr = decimal_to_percent(ini_sys:r_float_ex(section, "impair"))
			ammo.falloff = decimal_to_percent(ini_sys:r_float_ex(section, "k_air_resistance"))
			tbl[section] = ammo
			cnt = cnt + 1
		end
	end)

	local p_file = "export_ammo.csv"
	local debug_file = io.open(p_file,"w+")
	--csv header
	--write_file(debug_file, "~ ,      Name,   Weight kg, Base Cost, Projectiles,   Damage,   BR0,   BR1,   BR2,   BR3,   BR4,   BR5,   BR6,   Range,   Velocity,   Impulse,   Accuracy,   Degradation, Falloff")
	for section, v in pairs(tbl) do
		write_file(debug_file, "%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
		  --~ ,      Name,   BR0,   BR1,   BR2,   BR3,   BR4,   BR5,   BR6,   Projectiles,   Damage,   Accuracy,   Range,   Falloff,   Velocity,   Impulse,   Degradation, Weight kg, Base Cost,
			section, v.name, v.br1, v.br2, v.br3, v.br4, v.br5, v.br6, v.br7, v.projectiles, v.damage, v.accuracy, v.range, v.falloff, v.velocity, v.impulse, v.degr,      v.weight,  v.cost
		)
	end
	debug_file:close()

	x:SendOutput("[END] export ammo - %s total ammo exported - see in Gamma\\Overwrite\\bin\\export_ammo.csv", cnt)
end



function cmd.export_disassemble_table(_, txt, x)
	x:SendOutput("[START] export disassemble table")

	local blacklist = {
		["ammo"] = true,
		["st_memory_stick_name"] = true,
		["itm_guide_usb_1"] = true,
		["itm_guide_usb_2"] = true,
	}

	local ini_parts = itms_manager.ini_parts
	local tbl_disassemble = {}
	local tbl_materials = {}
	local disassemble_count = 0
	local materials_count = 0
	ini_sys:section_for_each(function(section)
		for black, _ in pairs(blacklist) do
			if string.find(section, black) then
				return
			end
		end

		local partsRaw = ini_parts:r_string_ex("nor_parts_list",section)
		if partsRaw == nil then
			return
		end
		local parts_tbl = str_explode(partsRaw,",")
		x:SendOutput("export disassemble item - %s", section)

		local disassemble = {}
		local item_name = game.translate_string(ini_sys:r_string_ex(section, "inv_name"))
		table.insert(disassemble, item_name)
		local parts = {}
		for i, part in ipairs(parts_tbl) do
			local repeat_number = tonumber(part)
			if repeat_number == nil then
				repeat_number = 1
			end
			for k = 1, repeat_number do
				if not parts[part] then
					parts[part] = {}
					parts[part].count = 0
				end
				parts[part].count = parts[part].count + 1
			end
		end

		local sortByCount = function(t,a,b) return t[a].count > t[b].count end

		for part_section, part in spairs(parts, sortByCount) do
			local part_name = game.translate_string(ini_sys:r_string_ex(part_section, "inv_name"))
			local parts_count = part.count
			table.insert(disassemble, part_name)
			table.insert(disassemble, "x" .. parts_count)

			if not tbl_materials[part_section] then
				tbl_materials[part_section] = {}
				tbl_materials[part_section].name = part_name
				tbl_materials[part_section].results = {}
				materials_count = materials_count + 1
			end

			tbl_materials[part_section].results[section] = {}
			tbl_materials[part_section].results[section].name = item_name
			tbl_materials[part_section].results[section].count = parts_count
		end

		tbl_disassemble[section] = disassemble
		disassemble_count = disassemble_count + 1
	end)

	local disassembles_file_name = "export_disassemble_table.csv"
	local disassembles_file = io.open(disassembles_file_name,"w+")
	local sortResultsByName = function(t, a, b) return t[a][1] < t[b][1] end
	for section, item in spairs(tbl_disassemble, sortResultsByName) do
		local value = "" .. section
		for i, materialOrCount in ipairs(item) do
			value = value .. "," .. "\"" .. materialOrCount .. "\""
		end

		write_file(disassembles_file, "%s", value)
	end
	disassembles_file:close()

	x:SendOutput("[PROGRESS-1] export disassemble - %s total disassembles exported - see in Gamma\\Overwrite\\bin\\export_disassemble_table.csv", disassemble_count)

	local materials_file_name = "export_disassembles_materials.csv"
	local materials_file = io.open(materials_file_name,"w+")
	local sortMaterialsByCount = function(t,a,b) return t[a].count > t[b].count end
	local sortMaterialsByName = function(t,a,b) return t[a].name < t[b].name end
	for section, part in spairs(tbl_materials, sortMaterialsByName) do
		local value = "" .. section .. "," .. "\"" .. (part.name or "None") .. "\""
		for i, result in spairs(part.results, sortMaterialsByCount) do
			value = value .. "," .. result.count .. " from," .. "\"" .. result.name .. "\""
		end

		write_file(materials_file, "%s", value)
	end

	x:SendOutput("[END] export materials - %s total materials exported - see in Gamma\\Overwrite\\bin\\export_disassembles_materials.csv", materials_count)
end



function cmd.print_outfits_props(_,txt,x)
	x:SendOutput("[START] print outfit props")
	
	local outfit_cls = {
		["o_helmet"]    = true,
		["E_HLMET"]     = true,
		["EQU_HLMET"]   = true,

		["o_light"]     = true,

		["E_STLK"]      = true,
		["EQU_STLK"]    = true,
		["o_medium"]    = true,
		["o_sci"]       = true,

		["o_heavy"]     = true,
	}
	
	local outfit_type = {
		["helmet"]              =  1 ,
		["helmet_light"]        =  2 ,
		["outfit"]              =  3 ,
		["outfit_novice"]       =  4 ,
		["outfit_trenchcoat"]   =  5 ,
		["outfit_sunrise"]      =  6 ,
		["outfit_lcs"]          =  7 ,
		["outfit_explorer"]     =  8 ,
		["outfit_sts"]          =  9 ,
		["outfit_ps5"]          =  10,
		["outfit_nbc"]          =  11,
		["outfit_assault_vest"] =  12,
		["outfit_seva"]         =  13,
		["outfit_ssp"]          =  14,
		["outfit_berill"]       =  15,
		["outfit_skat"]         =  16,
		["outfit_exolight"]     =  17,
		["outfit_proto_exo"]    =  18,
		["outfit_exoskeleton"]  =  19,
		["outfit_nosorog"]      =  20,
	}

	local p_file = "outfits_props.txt"
	local function write_file(text,...)
		if not text then return end
		local debug_file = io.open(p_file,"a+")

		if ( debug_file == nil ) then
			return
		end

		local i = 0
		local p = {...}
		local function sr(a)
			i = i + 1
			return tostring(p[i])
		end
		local output = string.gsub(text,"%%s",sr)
		debug_file:write(output.."\n")
		debug_file:close()
		exec_console_cmd("load ~#I#:"..output)
	end
	
	local tbl = {}
	local cnt = 0
	ini_sys:section_for_each( function(section)
		local class = ini_sys:r_string_ex(section,"class")
		local kind = ini_sys:r_string_ex(section,"kind") -- special class name for the sake of correct listing
		if kind then
			class = kind
		end
		if class and outfit_cls[class] then
			cnt = cnt + 1
			tbl[section] = {}
			tbl[section].typ = ini_sys:r_string_ex(section,"repair_type") or "na"
			tbl[section].indx = tbl[section].typ and outfit_type[tbl[section].typ] or 0
			
			tbl[section].cost = ini_sys:r_float_ex(section,"cost") or "na"
			tbl[section].w = ini_sys:r_float_ex(section,"inv_weight") or "na"
			tbl[section].cw = ini_sys:r_float_ex(section,"additional_inventory_weight") or "na"
			tbl[section].arty = ini_sys:r_float_ex(section,"artefact_count") or "na"
			tbl[section].intria = ini_sys:r_float_ex(section,"control_inertion_factor") or "na"
			
			tbl[section].p_b = ini_sys:r_float_ex(section,"burn_protection") or "na"
			tbl[section].p_sh = ini_sys:r_float_ex(section,"shock_protection") or "na"
			tbl[section].p_r = ini_sys:r_float_ex(section,"radiation_protection") or "na"
			tbl[section].p_cb = ini_sys:r_float_ex(section,"chemical_burn_protection") or "na"
			tbl[section].p_t = ini_sys:r_float_ex(section,"telepatic_protection") or "na"
			tbl[section].p_st = ini_sys:r_float_ex(section,"strike_protection") or "na"
			tbl[section].p_e = ini_sys:r_float_ex(section,"explosion_protection") or "na"
			tbl[section].p_w = ini_sys:r_float_ex(section,"wound_protection") or "na"
			tbl[section].p_fw = ini_sys:r_float_ex(section,"fire_wound_protection") or "na"
			
			tbl[section].hit_f = ini_sys:r_float_ex(section,"hit_fraction_actor") or "na"
		end
	end)
	
	write_file("","")
	write_file("--------------------------------------")
	write_file("SYMBOLS:")
	write_file("","")
	write_file("w = inventory weight")
	write_file("cw = carry weight")
	write_file("arty = artefact slots")
	write_file("intria = control_inertion_factor")
	write_file("p_b = burn_protection")
	write_file("p_sh = shock_protection")
	write_file("p_r = radiation_protection")
	write_file("p_cb = chemical_burn_protection")
	write_file("p_t = telepatic_protection")
	write_file("p_st = strike_protection")
	write_file("p_e = explosion_protection")
	write_file("p_w = wound_protection")
	write_file("p_fw = fire_wound_protection")
	write_file("hit_f = hit_fraction_actor")
	write_file("","")
	write_file("--------------------------------------")
	write_file("OUTFIT STATS:")
	write_file("","")
	local functor = function(t,a,b) return t[a].indx < t[b].indx end
	for section,v in spairs(tbl,functor) do
		write_file("%s 		= type:%s | cost:%s | w:%s | cw:%s | arty:%s | intria:%s | p_b:%s | p_sh:%s | p_r:%s | p_cb:%s | p_t:%s | p_st:%s | p_e:%s | p_w:%s | p_fw:%s | hit_f:%s ", section, v.typ, v.cost, v.w, v.cw, v.arty, v.intria, v.p_b, v.p_sh, v.p_r, v.p_cb, v.p_t, v.p_st, v.p_e, v.p_w, v.p_fw, v.hit_f)
	end
	
	x:SendOutput("[END] print outfit props - %s outfits printed - see outfits_props.txt", cnt)
end

function cmd.release_target()
	local o = level.get_target_obj()
	if o then
		alife_release_id(o:id())
		x:SendOutput("-Released object: %s", o:name())
	else
		x:SendOutput("!No object found on cursor to release")
	end
end

function cmd.release_id(_,txt,x)
	local id = txt and tonumber(txt)
	if (not id) then
		x:SendOutput("!Missing ID to release. Ex: release_id 34132")
		return
	end
	
	local se_obj = alife_object(id)
	if (not se_obj) then
		x:SendOutput("!No server object by ID (%s) is found", id)
		return
	end
	
	x:SendOutput("-Released server object by ID (%s): %s", id, se_obj:name())
	alife_release(se_obj)
end

function cmd.calc_containers_weight(_,txt,x)
	local _cont = {}
	
	ini_sys:section_for_each(function(section)
		local con, arty
		if (string.find(section, "(lead.-_box)",3)) then
			con = "lead_box"
			arty = section:gsub("_lead_box", "")		
		elseif (string.find(section, "(af.-_iam)",3)) then
			con = "af_iam"
			arty = section:gsub("_af_iam", "")
		elseif (string.find(section, "(af.-_aac)",3)) then
			con = "af_aac"
			arty = section:gsub("_af_aac", "")
		elseif (string.find(section, "(af.-_aam)",3)) then
			con = "af_aam"
			arty = section:gsub("_af_aam", "")
		end
		
		if con and arty and ini_sys:section_exist(con) and ini_sys:section_exist(arty) then
			local arty_w = ini_sys:r_float_ex(arty,"inv_weight")
			local con_w = ini_sys:r_float_ex(con,"inv_weight")
			local new_weight = arty_w + con_w
			
			if (new_weight ~= ini_sys:r_float_ex(section,"inv_weight")) then
				_cont[section] = new_weight
				printf("~ calc_containers_weight | calculated new weight for [%s]: %s", section, new_weight)
			end
		end
	end)
	
	local function file_exists(path)
		return io.open(path) ~= nil
	end
	
	local cnt = 0
	local function on_execute(path,filename,quit)
		local fullpath = path.."\\"..filename
		local ltx = io.open(fullpath,"rb")
		if (ltx) then
			local data = ltx:read("*all")
			ltx:close()
			if (data) then
				
				local need_save
				for sec,wt in pairs(_cont) do
					if (string.find(data,"["..sec.."]",nil,true)) then
						
						ltx = utils_data.cfg_file(fullpath)
						if (ltx) then
							
							ltx:SetValue(sec, "inv_weight", wt)
							need_save = true
							cnt = cnt + 1
							printf("% calc_containers_weight | saved inv_weight [%s]->[%s]", sec, wt)
							
						end
					end
				end
				
				if need_save then
					ltx:SaveExt()
					printf("- ui_item_editor | saved changes for {%s}", fullpath)
				end
				return
			end
		end
	end
	
	local sp = getFS():update_path('$game_config$', "items\\items\\")
	sp = string.sub(sp,0,string.len(sp)-1)
	lua_ext.recurse_subdirectories_and_execute(sp,{"ltx"},on_execute)
	
	x:SendOutput("-(%s) Weight calculations for artefact containers is done", cnt)
end

function cmd.validate_wpn_upgrades(_,txt,x)
	exec_console_cmd("clear_log")
	x:SendOutput("-Started weapon upgrades scan")
	
	local ignore_param = {
		["cost"] = true,
		["value"] = true,
	}
	
	local prop_minus = {
		["prop_recoil"] = true,
		["prop_weight"] = true,
	}
	
	local scan_list = {}
	local n, result, par, value = 0,"","",""
	local s_find = string.find
	local parameters = ui_debug_item.parameters["weapon"]
	
	ini_sys:section_for_each(function(section)
		local valid_wpn = ini_sys:r_string_ex(section,"upgrades") and ini_sys:r_float_ex(section,"rpm") and (not s_find(section,"tch_")) and (not s_find(section,"mp_")) and (not s_find(section,"_base"))
		if valid_wpn then
			local sec = ini_sys:r_string_ex(section,"parent_section") or section	
			
			-- Gather upgrades
			local upgrades = utils_item.get_upgrades_tree(section)
			if upgrades and is_not_empty(upgrades) and (not scan_list[sec]) then
				scan_list[sec] = {}
				
				for row,v in pairs(upgrades) do
					for clmn,u in pairs(v) do
						local u_sec = u.stats
						--printf("~ [%s] scanning upgrade %s", sec, u_sec)
						
						n = ini_sys:line_count(u_sec)
						for i=0,n-1 do
							result, par, value = ini_sys:r_line_ex(u_sec,i,"","")
							value = tonumber(value)
							if value and (parameters[par]) and (not ignore_param[par]) then
								if (not scan_list[sec][par]) then
									scan_list[sec][par] = ini_sys:r_float_ex(sec,par)
									--printf("- [%s] param: %s = %s", sec, par, scan_list[sec][par])
								end
								if scan_list[sec][par] then
									scan_list[sec][par] = scan_list[sec][par] + value
									--printf("- [%s] param modifier in upgr [%s]: %s = %s", sec, u_sec, par, value)
								else
									printf("! [%s] param [%s]: %s don't exist", sec, par)
								end
								
							elseif value and (par == "value") and u.prop and (#u.prop == 1) then
								if prop_minus[u.prop[1]] and (value > 0) then
									printf("! [%s] with property [%s] has positive value, it should be the opposite", u_sec, u.prop[1])
								elseif (prop_minus[u.prop[1]] == nil) and (value < 0) then
									printf("! [%s] with property [%s] has negative value, it should be the opposite", u_sec, u.prop[1])
								end
							end
						end
					end
				end
			end
			
		end
	end)
	
	for sec, v in pairs(scan_list) do
		for par, val in pairs(v) do
			local _min = parameters[par].min
			local _max = parameters[par].max
			if (val <= _min) or (val >= _max) then
				printf("! [%s] param (%s) get fucked on full upgrade: %s", sec, par, val)
			end
		end
	end
	
	printf("- Finished upgrades scan")
	x:SendOutput("-Finished upgrades scan")
end

function cmd.validate_outfit_upgrades(_,txt,x)
	exec_console_cmd("clear_log")
	x:SendOutput("-Started outfit upgrades scan")
	
	local ignore_param = {
		["cost"] = true,
		["value"] = true,
	}
	
	local scan_list = {}
	local n, m, result, par, value, o_value = 0,0,"","","",""
	local s_find = string.find
	local parameters = ui_debug_item.parameters["outfit"]
	
	ini_sys:section_for_each(function(section)
		local valid_outfit = ini_sys:r_string_ex(section,"upgrades") and ini_sys:r_string_ex(section,"bones_koeff_protection") and (not s_find(section,"tch_")) and (not s_find(section,"mp_")) and (not s_find(section,"_base"))
		if valid_outfit then
			local sec = ini_sys:r_string_ex(section,"parent_section") or section	
			
			-- Gather upgrades
			local upgrades = utils_item.get_upgrades_tree(section)
			if upgrades and is_not_empty(upgrades) and (not scan_list[sec]) then
				scan_list[sec] = {}
				
				for row,v in pairs(upgrades) do
					for clmn,u in pairs(v) do
						local u_sec = u.stats
						--printf("~ [%s] scanning upgrade %s", sec, u_sec)
						
						n = ini_sys:line_count(u_sec)
						for i=0,n-1 do
							result, par, value = ini_sys:r_line_ex(u_sec,i,"","")
							o_value = value
							value = tonumber(value)
							if o_value and (parameters[par] or (par == "immunities_sect_add")) and (not ignore_param[par]) then
								if (not scan_list[sec][par]) then
									scan_list[sec][par] = ini_sys:r_float_ex(sec,par)
									--printf("- [%s] param: %s = %s", sec, par, scan_list[sec][par])
								end
								if scan_list[sec][par] then
									scan_list[sec][par] = scan_list[sec][par] + value
									--printf("- [%s] param modifier in upgr [%s]: %s = %s", sec, u_sec, par, value)
								
								elseif (par == "immunities_sect_add") and o_value then
									m = ini_sys:line_count(o_value)
									for j=0,m-1 do
										result, par, value = ini_sys:r_line_ex(o_value,j,"","")
										value = tonumber(value)
										if value and (parameters[par]) and (not ignore_param[par]) then
											if (not scan_list[sec][par]) then
												local immunity = ini_sys:r_string_ex(sec,"immunities_sect")
												scan_list[sec][par] = ini_sys:r_float_ex(immunity,par)
												--printf("- [%s] param: %s = %s", sec, par, scan_list[sec][par])
											end
											if scan_list[sec][par] then
												scan_list[sec][par] = scan_list[sec][par] + value
												--printf("- [%s] param modifier in upgr [%s]: %s = %s", sec, u_sec, par, value)
											else
												printf("! [%s] param [%s]: %s don't exist", sec, par)
											end
										end
									end
								else
									printf("! [%s] param [%s]: %s don't exist", sec, par)
								end
							end
						end
					end
				end
			end
			
		end
	end)
	
	for sec, v in pairs(scan_list) do
		for par, val in pairs(v) do
			local _min = parameters[par].min
			local _max = parameters[par].max
			if (val < _min) or (val > _max) then
				printf("! [%s] param (%s) get fucked on full upgrade: %s", sec, par, val)
			end
		end
	end
	
	printf("- Finished upgrades scan")
	x:SendOutput("-Finished upgrades scan")
end

function cmd.dump_system_ini()
	ini_sys:save_as('system_full.ltx')
end

function cmd.dump_section(_,txt)
	if txt and not (txt == '') and ini_sys:section_exist(txt) then
		utils_data.print_table(utils_data.parse_ini_section_to_array(ini_sys,txt), txt)
	end
end

function cmd.test_squad(_,txt,o)
	local comm = alife():actor():community():sub(7)
	local sim = alife()
	comm = comm == 'dolg' and 'duty' or comm
	comm = comm == 'army' and 'military' or comm
	local num = 3	
	if txt and not (txt == '') then
		num = tonumber(txt) or num
	end
	
	local id = smart_terrain.nearest_to_actor_smart.id
	local smart = id and alife_object(id)
	
	if smart then
		local npc_sec = strformat('sim_default_%s_0', comm)
		o:SendOutput('spawning %s [%s] at %s', num, npc_sec, smart:name())
		
		local squad = sim:create('online_offline_group',smart.position,smart.m_level_vertex_id,smart.m_game_vertex_id)

		for i=1, num do
			squad:add_squad_member(npc_sec, smart.position,smart.m_level_vertex_id,smart.m_game_vertex_id)
		end
		
		squad:set_squad_relation()
		squad:refresh()
	
		SIMBOARD:assign_squad_to_smart(squad, smart.id)

		for k in squad:squad_members() do
			local se_obj = k.object or k.id and sim:object(k.id)
			if (se_obj) then
				SIMBOARD:setup_squad_and_group(se_obj)
			end
		end	
		squad.scripted_target = smart:name()
		return 'ok'
	end	
	return 'no smart'
end

function cmd.toggle_all_talk(_,__,o)
	local old = load_var(db.actor,"force_all_talk", false)
	save_var(db.actor,"force_all_talk",not old)
	o:SendOutput('force all talk: %s', not old)
	return "warning, keeping this active may cause problems, disable as soon you talked to the unresponsive npc"
end